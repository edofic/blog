<!doctype html><html><head><title>Making a programming language Part 8 - going faster</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.3bdd3e0bba961aa48fdce1402e6f01783c435b4dfb0025c8d0022ddaea0f3d19.css media=screen><script src=/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>My Programming Escapades</div><div class=nav-subtitle>Andraz Bajt</div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>My Programming Escapades</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>My Programming Escapades</div><div class=single-column-header-subtitle>Andraz Bajt</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Making a programming language Part 8 - going faster<div class=post-meta><time itemprop=datePublished>2012-09-29</time></div></div></div><div class=post-body-wrapper><div class=post-body><p><a href=/posts/2012-08-29-creating-a-language-1>Table of contents</a>, 
<a href=https://github.com/edofic/scrat-lang>Whole project on github</a></p><p>First of all, I wrote some tests for scrat. That was a bit challenging
to get started. How do you test a language? I decided to write a bunch
of programs that exercise and combine different language features. And
then stare into code until I was absolutely sure they are correct.
That&rsquo;s the problem with implementing a new language, nobody can tell you
if your code is correct but your software, but you don&rsquo;t even know if
software is correct.
So I wrote some test programs and
<a href=http://en.wikipedia.org/wiki/Parsing title=Parsing>parsed</a> and evaluated
them in my mind to produce final result. And then I wrote a class using
ScalaTest that generates tests by iterating over the array of these
<a href=http://en.wikipedia.org/wiki/Tuple title=Tuple>tuples</a>. Quite cool, oh and
I also included some descriptions into the tuples. So I get nice output.
I pondered this idea quite some time ago but finally implemented it a
bit after functions and objects.</p><p>So now I can do crazy
<a href=http://www.techopedia.com/definition/3865/refactoring title=Refactoring>refactorings</a>
while still maintaining the language - I trust my tests! But first of
all, some benchmarks. I decided to measure execution time of parsing and
evaluation on the <a href=https://raw.github.com/edofic/scrat-lang/master/run/llist.scrat>linked-list
consturctor</a>.
To my surprise, parsing was quite slow. It started on about 800ms and
dropped down to 200ms after a few executions(first time <a href=http://en.wikipedia.org/wiki/Object_lifetime title="Object lifetime">object
creation</a>
and
<a href=http://en.wikipedia.org/wiki/Just-in-time_compilation title="Just-in-time compilation">JIT</a>
I suppose). 200ms for 67 <a href=http://en.wikipedia.org/wiki/Source_lines_of_code title="Source lines of code">lines of
code</a>?
That would mean about 3 seconds on a 1000 line file <strong>IF</strong> complexity is
linear(which I later leart isn&rsquo;t!). And that&rsquo;s 3 seconds on fifth run
or so, first run(which is the only one when doing real stuff) would be
10 seconds+, unacceptable. (evaluation takes a few ms)</p><h3 id=research>Research</h3><p>At first I just gave it some thought. Well it&rsquo;s a <strong>recursive</strong> descent
parser, and from what I remember it back traces on failure. So
efficiency has a lot to do with grammar structure. And it won&rsquo;t be
linear because you have to do (usually) more back tracing when dealing
with longer input.</p><p>Internets here I come. </p><p>My thoughts were confirmed. I found some guys on forums complaining over
speed and then Mr. Odersky himself commented something like this(from
memory):</p><blockquote><p>Well the parsers in scala standard library are more like an example
how to do recusive descent, functional style. They are perfectly
usable for parsing command lines but not for long files. You should
use a parser generator for that.</p></blockquote><p>I was bummed. The reason I didn&rsquo;t use a parser generator was this close
integration that parser as a library could provide me. By the way
implementation of
<a href=http://en.wikipedia.org/wiki/Parsing title=Parsing>Parsers</a> is remarkably
short, ~800 lines but most of them are comments. But it has quite some
problems. A lot of object creation - every time a parsing function is
invoked <strong>many object are created</strong>. Each parser is an object and each
combinator is an object too. This in itself is not a big deal, but no
<a href=http://en.wikipedia.org/wiki/Memoization title=Memoization>memoization</a> is
performed, so it becomes a big deal. Now many objects are created on
each try, so when backtracing you have to
<a href=http://www.techopedia.com/definition/27271/automatic-memory-management-amm title="Automatic Memory Management">GC</a>
all these object and then recreate them. It&rsquo;s clean but it&rsquo;s no wonder
it&rsquo;s slow.
Some time passed by and I accidentally found out about <a href=http://en.wikipedia.org/wiki/Parsing_expression_grammar title="Parsing expression grammar">Packrat
Parsing</a>.
<a href=http://scala-programming-language.1934581.n4.nabble.com/attachment/1956909/0/packrat_parsers.pdf>This paper</a>
provides details but the gist of it is to use <a href=http://en.wikipedia.org/wiki/Lazy_evaluation title="Lazy evaluation">lazy
evaluation</a>
and memoization to reduce object creation and speed things up.</p><h3 id=conversion-and-results>Conversion and results</h3><p>Conversion is dead easy. It&rsquo;s fully described in scala api
documentation. Basically you mix in PackratParsers and change
<code>def : Parser[] = ...</code> to <code>lazy val : PackratParser[] = ...</code> and that&rsquo;s it. Mixed
in trait provides the necessary implicit conversions, lazy makes sure
the creation is only done once and new implementation of parseAll does
some clever parsing. Oh and you needn&rsquo;t convert all parsers, the paper
says the optimal perfomance is achieved with the right mix of standard
<a href=http://en.wikipedia.org/wiki/Recursive_descent_parser title="Recursive descent parser">recursive descent
parsers</a>
and packrat(packrat does include some overhead on specific grammars and
inputs). But I just converted all and run the benchmark again. And
behold&mldr;11ms. On the best run. More like 15 on average. But that&rsquo;s
still more than a whole order of magnitude faster. And it should scale
better. </p><p><strong>next:</strong> don&rsquo;t know yet. I caught up with my implementation(finally!). I
thinking about making functions stronger by relaxing the rules of
invocation and doing some syntax sugar for lambdas. That and java
interop. Or possibly compiling to bytecode. </p><hr width=100%><p style=color:#777>Last modified on 2012-09-29</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2012-10-08-creating-a-language-7b/>Next<br>Making a programming language Part 7b - using objects</a>
<a class=older-posts href=/posts/2012-09-27-creating-a-language-7a/>Previous<br>Making a programming language Part 7a - objects</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div><script src=//js/journal.js></script></body></html>