---
title: Cool Monday: Functional compilers and atoms
---

I've seen <a href="http://skillsmatter.com/podcast/scala/functional-compilers-from-cfg-to-exe/ac-5896" target="_blank">this great talk</a> by Daniel Spiewak on Functional <a href="http://en.wikipedia.org/wiki/Compiler" rel="wikipedia" target="_blank" title="Compiler">Compilers</a>. He talks about lexical and <a href="http://en.wikipedia.org/wiki/Compiler" rel="wikipedia" target="_blank" title="Compiler">semantic analysis</a> in particular.<br />First, problems with traditional <a href="http://en.wikipedia.org/wiki/Lexical_analysis" rel="wikipedia" target="_blank" title="Lexical analysis">lexing</a> with scanner. You can only have regular tokens or you have do do some dirty hacking and <a href="http://en.wikipedia.org/wiki/Stack_trace" rel="wikipedia" target="_blank" title="Stack trace">backtrace</a> the scanner therefore losing linearity. And you can solve this with <a href="http://en.wikipedia.org/wiki/Scannerless_parsing" rel="wikipedia" target="_blank" title="Scannerless parsing">scannerless parsing</a> - putting <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="wikipedia" target="_blank" title="Regular expression">regular expressions</a> into your grammar. In fact this approach seems simpler to me, as the <a href="http://www.edofic.com/2012/08/making-programming-language-part-1-how.html" target="_blank">only proper parser I've done</a> works this way. But this is not the interesting part.<br /><br /><h3>Semantic analysis</h3><div>This is where fun kicks in. After you parse the <a href="http://en.wikipedia.org/wiki/Source_code" rel="wikipedia" target="_blank" title="Source code">source code</a> into an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="wikipedia" target="_blank" title="Abstract syntax tree">AST</a> you need to do a bunch of operations on it. Naming, typing(even optimization in later phases). If I want to stay functional(which usually I do) my instinct tells me to do recursive traversal and rewrite the tree. And that's exactly what my language does. But there is one huge problem. AST is not a tree. It's huge misnomer. AST is just a <a href="http://en.wikipedia.org/wiki/Spanning_tree" rel="wikipedia" target="_blank" title="Spanning tree">spanning tree</a> in the program graph. See, when you add stuff like let expressions, or types(what I'm doing currently) you get problems</div><pre>let a = 1<br />in f a<br /></pre><div>There are edges between the siblings. Or going back up. Or skipping levels. Definitely not trees. These edges may be implicit but you still have to store the information. Traditional solution to this is to compute look-up tables(maps) and carry them along with the tree. So the AST remains a tree but it has some additional stuff that implicitly makes it into a graph. Problem is this gets nasty when you carry along a lot of information and you have to be careful with you updates.<br />There is one more solution. Vars. Works like a charm. Except that it's terrible to reason about quite the opposite of functional. But there exists a fix.<br /><h3>Atoms</h3></div><div>Think write-once vars. But not quite. The idea is to have containers that can be written to but are only ever seen in a one state. Problem with vars is that they can be seen  in multiple states and you have to keep track of these states. Vals solve this by not letting you mutate state. And lazy vals provide machinery to delay initialization(great for solving circular dependencies). But they don't let you escape the scope. Or deal with a situation when you need to init them when you have data not when you need to read them. And this is the problem in a compiler. You compute data coming from out of the scope and you need to store it. And some time later you need to read it. And you use atoms.  First some code, then explanation.</div><pre>class Atom[A] {<br />  private var value: A = _<br />  private var isSet = false<br />  private var isForced = false<br />    <br />  protected def populate(){<br />    sys.error("cannont self-populate atom")<br />  }<br />    <br />  def update(a: A) {<br />    if (!isSet || !isForced){<br />      value = a<br />      isSet = true<br />    }<br />  }<br />    <br />  def apply(): A {<br />    isForced = true<br />       <br />    if (isSet) {<br />      value<br />    } else {<br />      populate()<br />            <br />      if (!isSet) {<br />        sys.error("value not set")<br />      }<br />      value<br />    }<br />  }   <br />}<br /></pre><div>Here is the workflow... you create an atom, you can write(update) to it-in fact writes are indempotent and you can do many successive writes as long as you don't read the value. Once written to isSet flag is set and atom can be read(apply method) setting the isForced flag. If the atom isn't set when you try to read it it will try to populate itself. Populate method is intended to be overwritten and may contain data in it's closure or even perform some side-effects. And you can safely assume it will only execute once. And if everything fails and atom isn't set you get an error. Yay no bothering with nulls any more.<br />You can quickly see how atoms are great containers for storing computed information in the AST for passing it on to the later stages.</div><div style="margin-top: 20px; overflow: hidden;">