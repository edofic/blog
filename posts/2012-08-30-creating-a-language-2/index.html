<!doctype html><html><head><title>Making a programming language Part 2 - something that kinda works</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.3bdd3e0bba961aa48fdce1402e6f01783c435b4dfb0025c8d0022ddaea0f3d19.css media=screen><script src=/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>My Programming Escapades</div><div class=nav-subtitle>Andraz Bajt</div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>My Programming Escapades</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>My Programming Escapades</div><div class=single-column-header-subtitle>Andraz Bajt</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Making a programming language Part 2 - something that kinda works<div class=post-meta><time itemprop=datePublished>2012-08-30</time></div></div></div><div class=post-body-wrapper><div class=post-body><p><a href=/posts/2012-08-29-creating-a-language-1>Table of contents</a>,
<a href=https://github.com/edofic/scrat-lang>Whole project on github</a>,
<a href=https://github.com/edofic/scrat-lang/tree/blogpost1and2>relevant version on github</a></p><p>In the <a href=/posts/2012-08-29-creating-a-language-1>Part 1</a> I posted a working
repl(<a href=http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop title="Read–eval–print loop">read-eval-print-loop</a>)
for simple math expressions but I kinda cheated and only explained how I
built the <a href=http://en.wikipedia.org/wiki/Abstract_syntax_tree title="Abstract syntax tree">AST</a>.</p><h3 id=ast-elements>AST elements</h3><p>Just <a href=http://www.scala-lang.org/ title="Scala (programming language)">scala</a> case classes</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Expression</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Number</span><span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Expression</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Add</span><span style=color:#f92672>(</span>left<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>,</span> right<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Expression</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Subtract</span><span style=color:#f92672>(</span>left<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>,</span> right<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Expression</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Multiply</span><span style=color:#f92672>(</span>left<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>,</span> right<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Expression</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Divide</span><span style=color:#f92672>(</span>left<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>,</span> right<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Expression</span>
</code></pre></div><h3 id=parser-combinatorshttpenwikipediaorgwikiparser-combinator-parser-combinator-revisited><a href=http://en.wikipedia.org/wiki/Parser_combinator title="Parser combinator">Parser combinators</a> revisited</h3><p>I use power of scala library to cheat a bit and do lexing and
<a href=http://en.wikipedia.org/wiki/Parsing title=Parsing>parsing</a> in one
step.Basic parser combinators from scala api documentation, everything
you need to define productions in your grammar.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>p1 <span style=color:#f92672>~</span> p2 <span style=color:#75715e>// sequencing: must match p1 followed by p2
</span><span style=color:#75715e></span>p1 <span style=color:#f92672>|</span> p2 <span style=color:#75715e>// alternation: must match either p1 or p2, with preference given to p1
</span><span style=color:#75715e></span>p1<span style=color:#f92672>.</span><span style=color:#f92672>?</span>    <span style=color:#75715e>// optionality: may match p1 or not
</span><span style=color:#75715e></span>p1<span style=color:#f92672>.</span><span style=color:#f92672>*</span>    <span style=color:#75715e>// repetition: matches any number of repetitions of p1
</span></code></pre></div><p>However, to transform the matched string to an AST you need something
more</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>def</span> number<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Parser</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Expression</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#e6db74>&#34;&#34;&#34;\d+\.?\d*&#34;&#34;&#34;</span><span style=color:#f92672>.</span>r <span style=color:#f92672>^^</span> <span style=color:#f92672>{</span>
  s <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Number</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span>toDouble<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Firstly, in the <code>RegexParser</code> class is an <a href=http://en.wikipedia.org/wiki/Type_conversion title="Type conversion">implicit conversion</a>
from <code>Regex</code> to Parser. So I could write</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>def</span> number<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Parser</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#e6db74>&#34;&#34;&#34;\d+\.?\d*&#34;&#34;&#34;</span><span style=color:#f92672>.</span>r
</code></pre></div><p>Notice the <a href=http://en.wikipedia.org/wiki/Type_signature title="Type signature">type annotation</a>.
Inferred type would be Regex, since this function is private I can still
have implicit conversion, but I rather have all parsers be of type
<code>Parser[_]</code>.The <code>^^</code> part is an action combinator - a <a href=http://en.wikipedia.org/wiki/Map_%28higher-order_function%29 title="Map (higher-order function)">map
function</a>.
But as <code>^^</code> is only available on Parser instances my regex has already
been implicitly converted. So in my lambda I already know(scala can
infer) the type of s to be String. One last example</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>def</span> term<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Parser</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Expression</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> factor <span style=color:#f92672>~</span> rep<span style=color:#f92672>(</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>~</span> factor<span style=color:#f92672>)</span> <span style=color:#f92672>^^</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>case</span> head <span style=color:#f92672>~</span> tail <span style=color:#66d9ef>=&gt;</span>
    <span style=color:#66d9ef>var</span> tree<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span> <span style=color:#f92672>=</span> head
    tail<span style=color:#f92672>.</span>foreach <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#f92672>~</span> e <span style=color:#66d9ef>=&gt;</span> tree <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Multiply</span><span style=color:#f92672>(</span>tree<span style=color:#f92672>,</span> e<span style=color:#f92672>)</span>
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>~</span> e <span style=color:#66d9ef>=&gt;</span> tree <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Divide</span><span style=color:#f92672>(</span>tree<span style=color:#f92672>,</span> e<span style=color:#f92672>)</span>
    <span style=color:#f92672>}</span>
    tree
<span style=color:#f92672>}</span>
</code></pre></div><p>Function rep is also from Parsers class matches any number of
repetitions(including 0). Here's the type signature</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> rep<span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>p<span style=color:#66d9ef>:</span> <span style=color:#f92672>⇒</span> <span style=color:#a6e22e>Parser</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Parser</span><span style=color:#f92672>[</span><span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>]</span>
</code></pre></div><p>The catch here is that <code>~</code> returns a single parser that matches both
sides, but fortunately it can be pattern matched to extract both sides.
And I can even use meaningful names since I am in fact matching a head
with an optional tail. Inside the <a href=http://en.wikipedia.org/wiki/Switch_statement title="Switch statement">case
statement</a>
I used more imperative style to build a tree, nothing fancy here.
Folding was a bit awkward in this case for me(maybe I'm just
incompetent) so I went with a for each loop.Apply the same pattern to
+/- part and you have yourself a tree.Oh, yeah&mldr;and the top parser
function. A bit changed from last time, to yield useful error messages</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>s<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Expression</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> parseAll<span style=color:#f92672>(</span>expr<span style=color:#f92672>,</span> s<span style=color:#f92672>)</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>tree<span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Right</span><span style=color:#f92672>(</span>tree<span style=color:#f92672>)</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>NoSuccess</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Left</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=evaluator>Evaluator</h3><p>Now what I promised in previous post - evaluation. At first I planned on
compiling the code for JVM but I just wanted to see some results first
so I decided to do a simple interpreter, no compiling whatsoever - for
now. My first approach was to modify the Expression</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Expression</span><span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> eval<span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>and implement this on all case classes hardcoding the double type and
coupling AST representation and evaluation together. Yikes. Granted, it
worked, but what an ugly way to do it. So I did a hard reset(always use
git folks! or something similar) and went about doing a standalone
evaluator. Since scala's pattern matching skills are awesome and I'm
already using case classes why not just do that.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Evaluator</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>import</span> Tokens._
  <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>e<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span> <span style=color:#f92672>=</span> e <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Number</span><span style=color:#f92672>(</span>n<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> n
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Add</span><span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> apply<span style=color:#f92672>(</span>l<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> apply<span style=color:#f92672>(</span>r<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Subtract</span><span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> apply<span style=color:#f92672>(</span>l<span style=color:#f92672>)</span> <span style=color:#f92672>-</span> apply<span style=color:#f92672>(</span>r<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Multiply</span><span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> apply<span style=color:#f92672>(</span>l<span style=color:#f92672>)</span> <span style=color:#f92672>*</span> apply<span style=color:#f92672>(</span>r<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Divide</span><span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> apply<span style=color:#f92672>(</span>l<span style=color:#f92672>)</span> <span style=color:#f92672>/</span> apply<span style=color:#f92672>(</span>r<span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>This is all the code. Just pattern matching and recursion. But yes,
still hardcoded double as the data-type. Looking back, not a great
decision&mldr;but hey I got something working and this is fun.</p><p><strong>next time: <a href=/posts/2012-08-31-creating-a-language3>Adding features(contants, exponents, function calls)</a></strong></p><hr width=100%><p style=color:#777>Last modified on 2012-08-30</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2012-08-31-creating-a-language3/>Next<br>Making a programming language Part 3 - adding features</a>
<a class=older-posts href=/posts/2012-08-29-creating-a-language-1/>Previous<br>Making a programming language Part 1 - how to start</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div><script src=//js/journal.js></script></body></html>