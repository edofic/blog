---
title: Making a programming language: Part 2 - something that kinda works
---

<a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" target="_blank">Table of contents</a>, <a href="https://github.com/edofic/scrat-lang" target="_blank">Whole project on github</a>, <a href="https://github.com/edofic/scrat-lang/tree/blogpost1and2" target="_blank">relevant version on github</a><link href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css" rel="stylesheet" type="text/css"></link>
<br/>
In the <a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" target="_blank">Part 1</a> I posted a working repl(<a href="http://en.wikipedia.org/wiki/Read–eval–print_loop" rel="wikipedia" target="_blank" title="Read–eval–print loop">read-eval-print-loop</a>) for simple math expressions but I kinda cheated and only explained how I built the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="wikipedia" target="_blank" title="Abstract syntax tree">AST</a>.<h3>AST elements</h3><div>Just <a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">scala</a> case classes</div><pre>sealed trait Expressioncase class Number(n: Double) extends Expressioncase class Add(left: Expression, right: Expression) extends Expressioncase class Subtract(left: Expression, right: Expression) extends Expressioncase class Multiply(left: Expression, right: Expression) extends Expressioncase class Divide(left: Expression, right: Expression) extends Expression</pre><div></div><h3><a href="http://en.wikipedia.org/wiki/Parser_combinator" rel="wikipedia" target="_blank" title="Parser combinator">Parser combinators</a> revisited</h3>I use power of scala library to cheat a bit and do lexing and <a href="http://en.wikipedia.org/wiki/Parsing" rel="wikipedia" target="_blank" title="Parsing">parsing</a> in one step.Basic parser combinators from scala api documentation, everything you need to define productions in your grammar.<pre>p1 ~ p2 // sequencing: must match p1 followed by p2p1 | p2 // alternation: must match either p1 or p2, with preference given to p1p1.?    // optionality: may match p1 or notp1.*    // repetition: matches any number of repetitions of p1</pre>However, to transform the matched string to an AST you need something more<pre>private def number: Parser[Expression] = """\d+\.?\d*""".r ^^ {  s => Number(s.toDouble)}</pre>Firstly, in the RegexParser class is an <a href="http://en.wikipedia.org/wiki/Type_conversion" rel="wikipedia" target="_blank" title="Type conversion">implicit conversion</a> from <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="wikipedia" target="_blank" title="Regular expression">Regex</a> to Parser. So I could write<pre>private def number: Parser[<a href="http://en.wikipedia.org/wiki/String_%28computer_science%29" rel="wikipedia" target="_blank" title="String (computer science)">String</a>] = """\d+\.?\d*""".r</pre>Notice the <a href="http://en.wikipedia.org/wiki/Type_signature" rel="wikipedia" target="_blank" title="Type signature">type annotation</a>. Inferred type would be Regex, since this function is private I can still have implicit conversion, but I rather have all parsers be of type Parser[_].The ^^ part is an action combinator - a <a href="http://en.wikipedia.org/wiki/Map_%28higher-order_function%29" rel="wikipedia" target="_blank" title="Map (higher-order function)">map function</a>. But as ^^ is only available on Parser instances my regex has already been implicitly converted. So in my lambda I already know(scala can infer) the type of s to be String.One last example<pre>private def term: Parser[Expression] = factor ~ rep(("*" | "/") ~ factor) ^^ {      case head ~ tail => {        var tree: Expression = head        tail.foreach {          case "*" ~ e => tree = Multiply(tree, e)          case "/" ~ e => tree = Divide(tree, e)        }        tree      }    }</pre>Function rep is also from Parsers class matches any number of repetitions(including 0). Here's the type signature <pre>def rep[T](p: ⇒ Parser[T]): Parser[List[T]]</pre>The catch here is that ~ returns a single parser that matches both sides, but fortunately it can be pattern matched to extract both sides. And I can even use meaningful names since I am in fact matching a head with an optional tail.Inside the <a href="http://en.wikipedia.org/wiki/Switch_statement" rel="wikipedia" target="_blank" title="Switch statement">case statement</a> I used more imperative style to build a tree, nothing fancy here. Folding was a bit awkward in this case for me(maybe I'm just incompetent) so I went with a for each loop.Apply the same pattern to +/- part and you have yourself a tree.Oh, yeah...and the top parser function. A bit changed from last time, to yield useful error messages<pre>def apply(s: String): List[Expression] = parseAll(expr, s) match {    case Success(tree, _) => Right(tree)    case NoSuccess(msg, _) => Left(msg)}</pre><h3>Evaluator</h3><div>Now what I promised in previous post - evaluation. At first I planned on compiling the code for JVM but I just wanted to see some results first so I decided to do a simple interpreter, no compiling whatsoever - for now.My first approach was to modify the Expression</div><pre>sealed trait Expression{    def eval(): Double  }</pre><div>and implement this on all case classes hardcoding the double type and coupling AST representation and evaluation together. Yikes. Granted, it worked, but what an ugly way to do it.So I did a hard reset(always use git folks! or something similar) and went about doing a standalone evaluator. Since scala's pattern matching skills are awesome and I'm already using case classes why not just do that.<pre>object Evaluator {    import Tokens._    def apply(e: Expression): Double = e match {      case Number(n) => n      case Add(l, r) => apply(l) + apply(r)      case Subtract(l, r) => apply(l) - apply(r)      case Multiply(l, r) => apply(l) * apply(r)      case Divide(l, r) => apply(l) / apply(r)    }  }</pre>This is all the code. Just pattern matching and recursion. But yes, still hardcoded double as the data-type. Looking back, not a great decision...but hey I got something working and this is fun.<b><br/><br/>next time:</b> <a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-3.html" target="_blank">Adding features(contsnts, exponents, function calls)</a></div>S