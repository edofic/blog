---
title: Nomadic programming
---

DISCLAIMER: This is about my opinion. And may or may not contain some boasting. And is also a bit of a brain dump.<br /><br />Yep, this is not a typo. Not monadic but <a href="http://en.wikipedia.org/wiki/Nomad" rel="wikipedia" target="_blank" title="Nomad">nomadic</a>. Although monads are cool too.<br />A few days ago the <a href="http://en.wikipedia.org/wiki/Chief_technology_officer" rel="wikipedia" target="_blank" title="Chief technology officer">CTO</a> of a company I work for said it's time to specialize. He was talking about my career. Offering me a few things to try and then pick one. But this got me thinking.<br />Today another CTO told me that I'm "essentially a good dev" and that chosen <a href="http://en.wikipedia.org/wiki/Computer_software" rel="wikipedia" target="_blank" title="Computer software">software</a> stack doesn't matter. And I agree. (<a href="http://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/" target="_blank">Patrick does too</a>).<br /><table cellpadding="0" cellspacing="0" style="float: right; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://www.thatericalper.com/wp-content/uploads/2012/11/years.jpg" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="400" src="http://www.thatericalper.com/wp-content/uploads/2012/11/years.jpg" width="322" /></a></td></tr><tr><td style="text-align: center;">20 years later all this fits in your pocket</td></tr></tbody></table><span style="text-align: center;">I'm an <a href="http://en.wikipedia.org/wiki/Engineer" rel="wikipedia" target="_blank" title="Engineer">engineer</a> not a programmer(or god forbid, a <a href="http://en.wikipedia.org/wiki/Programmer" rel="wikipedia" target="_blank" title="Programmer">coder</a>). I solve problems not just write code. It just happens that code is <a href="http://en.wikipedia.org/wiki/Solution" rel="wikipedia" target="_blank" title="Solution">solution</a> to most problems I try to solve. World is increasingly more computer orientated. Now everything(literally!) has a processor inside. But processors are dumb. So you need people to program them. These people are the equivalent of the <a href="http://en.wikipedia.org/wiki/Factory" rel="wikipedia" target="_blank" title="Factory">factory workers</a> before robots started taking over. So now people need to migrate one level up on the abstraction ladder. Labor is now mental. Not everything is the same(like in a traditional factory) but it is the same concept. And you are pumping out slightly different versions.  Welcome to a modern software shop.</span><br />But all this "computerization" also pushes up the upper bound of complexity. And this is where engineers kick in. If you have complex solution you require (hopefully less) complex solutions. And you need people who can manage this complexion. Not by being machines but by understanding, inventing concepts and structuring them. Big software has millions if not billions of moving parts. Imagine a machine of such complexity. There probably isn't a human out there who could manage this in it's entirety. But software engineers are expected to do this. You need the ability to see something and relate it to known concepts or invent a new concept and relate it to oter stuff. Connect things together. And to do this well you need broad knowledge. Yes you need specialization - depth - to do something very well but this is a lesser problem. See a good engineer can go from zero to awesome in a new field <b>very quickly. </b>Learning a new language can be done in a week and a software stack in a bit more. I'm not saying you become an expert or the very best in the field but if you have the urge to learn you are not far behind. So a good engineer is the one who has the ability to learn and to produce real solutions with this knowledge.<br /><h3><br /></h3><h3>Nomads</h3><div>So where does nomadic programming fit into this philosophy? Going from language to language, from framework to framwork and changing software stacks. Not settling down. This (in my opinion) teaches you what can be done and haw can stuff be done. In all possible ways. So you can figure out the best solution. Learning all the time also keeps you on the bleeding edge and this is fun and engaging. Having new toys all the time! I can't image myself working with just one thing for the rest of my life. Meeting new languages and new framework is what I do in my <a href="http://en.wikipedia.org/wiki/Leisure" rel="wikipedia" target="_blank" title="Leisure">free time</a>. So when a customer says they need <a href="http://rubyonrails.org/" rel="homepage" target="_blank" title="Ruby on Rails">Ruby on Rails</a> and I never used it before....it's not a problem. I've seen ruby, I know python and I know how MVC is supposed to work. Putting it all together is not that hard. You can even hit the ground running and start working right away. Of course you'll be a bit slower in the start but you can catch up.  So no, I don't want to specialize. I want to know everything that is there to know! And I believe this will make me a better engineer. Or developer. Or person. And I believe that quality of their employees shoud matter to the employer. It is developers who create their products. </div><div><br /></div><div><b>You should always strive to become better!</b></div><div style="margin-top: 20px; overflow: hidden;">