---
title: Homework - functional style (outer sorting)
---

I'm attending Algorithms and data structures class this semester. Material it self is quite interesting and one TA is pretty cool too. But I don't like professor(makes whole experience very much worse) and I believe homeworks could be much better. Oh, and we didn't even mention functional approach...you know <a href="http://haskell.org/" rel="homepage" target="_blank" title="Haskell (programming language)">Haskell</a>, <a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">Scala</a> and the like. All we do is imperative, C-style code in Java. Enough ranting. This is how it saw the bright side.<br /><br /><h2>Le problem</h2>We were doing outer sorting. More specifically: balanced natural outer merge sort. I hope I translated this right(probably not). In it's essence the algorithm looks like this<br /><br /><ul><li>you have multiple tracks you read from and write to</li><li>you have the current element of each track in memory</li><li>you write out squads(non-descending sub-sequence), this means you take the minimum element that is greater than last of if such element doesn't exist you take the <a href="http://en.wikipedia.org/wiki/Maximal_element" rel="wikipedia" target="_blank" title="Maximal element">minimal element</a>. </li><li>every time a squad ends your write pointer hops to the next track.</li><li>repeat until all elements are on single track(hopefully sorted in non-descending order)</li></ul><div><table cellpadding="0" cellspacing="0" style="float: right; text-align: right;"><tbody><tr><td style="text-align: center;"><div><a href="http://commons.wikipedia.org/wiki/File%3ATapesticker.jpg" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="Reel of 1/2" tape showing beginning-of-ta..." border="0" class="zemanta-img-inserted" height="169" src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Tapesticker.jpg/300px-Tapesticker.jpg" style="border: none; font-size: 0.8em;" width="300" /></a></div></td></tr><tr><td style="text-align: center; width: 300px;">Reel of 1/2" tape showing beginning-of-tape reflective marker. (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3ATapesticker.jpg" target="_blank">Wikipedia</a>)</td></tr></tbody></table>Quite simple right? TA's even provided us classes(talking Java here) InTrack and OutTrack to manage tracks and I/O. Well my problem is that I grew to dislike imperative style. Surely it may matter for performance, but since this is a homework, performance didn't matter - so I wrote pretty code. I wanted my central code(the heart of the algorithm) to be a few lines at most. </div><div>This is my final product(bear in mind there was an additional twist: code should also be capable of sorting in non-ascending order thus the up variable).<br />Some additional explanation: all tracks should be in separate files(no overwriting - for automatic checking). N is number of tracks, prefix is track name prefix, and i is current iteration.</div><pre>int i = 0;<br />Iterable<Integer> source = new InTrack(inName);<br />MultiSink sink;<br />do{<br />    sink = new MultiSink(prefix, i, N, up);<br />    for(int n : source) sink.write(n);<br />    source = new MultiSource(prefix, i, N, up);<br />    i++;<br />} while (sink.isMoreThanOneUsed());<br /></pre>I'm, probably not allowed to share my full solution because of university rules so I won't.<br />Now to comment on this. I have a source that's agnostic to the amount of open files. And I have a similar sink. End-point switching is implemented in MultiSink and element choosing is in MultiSource. Both InTrack and MultiSource implement Iterable(and Iterator) so I can use them in a for-each loop. And code is as pretty as I can get it(remaining in java). All in all ~300 lines(with InTrack & stuff). After removing uneeded utility methods and comments ~220 lines. Eww.. Thats way too much.<br /><br /><h2>Scala to the rescue</h2><div>Lets rewrite this in a functional matter using scala. And while I'm at it, no vars or m<br /><table cellpadding="0" cellspacing="0" style="float: right; margin-right: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><div><a href="http://en.wikipedia.org/wiki/File%3AScala_logo.png" style="margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img alt="Scala (programming language)" border="0" class="zemanta-img-inserted" height="85" src="http://upload.wikimedia.org/wikipedia/en/thumb/8/85/Scala_logo.png/300px-Scala_logo.png" style="border: none; font-size: 0.8em;" width="300" /></a></div></td></tr><tr><td style="font-size: 13px; text-align: center; width: 300px;">Scala (programming language) (Photo credit: <a href="http://en.wikipedia.org/wiki/File%3AScala_logo.png" target="_blank">Wikipedia</a>)</td></tr></tbody></table>utable collections. </div><div>Input can be a collection right? Just implement Traversable. Not really. The whole point of tracks is they only hold one element in memory(or a few for efficiency but that's currently not my concern). So a track can be implemented as a <a href="http://en.wikipedia.org/wiki/Stream_%28computing%29" rel="wikipedia" target="_blank" title="Stream (computing)">Stream</a>(linked list with a lazy val for tail).</div><pre>def Reader(filename: String) = {<br />  val sc = new Scanner(new File(filename))<br />  def loop(): Stream[Int] = {<br />    if (sc.hasNextInt){<br />      sc.nextInt() #:: loop<br />    } else<br />      Stream.empty[Int]<br />  }<br />  loop()<br />}<br /></pre><div>This is the <a href="http://en.wikipedia.org/wiki/Constructor_%28object-oriented_programming%29" rel="wikipedia" target="_blank" title="Constructor (object-oriented programming)">constructor function</a> for the input stream. It just returns a recursive value that has a Scanner in its closure. As stream elements are immutable you get an iron clad guarantee that sc will stay in sync.   And you get all collections stuff for free. Moving on, how to abstract over multiple streams? That should be a stream again right? I kinda feel my code is too complicated and that it could be done simpler but that's what I came up with</div><pre>def MultiReader(prefix: String, phase: Int, N: Int, up: Boolean) = {<br />  def loop(last: Int, sources: Seq[Stream[Int]]): Stream[Int] = {<br />    val nonEmpty = sources.filterNot(_.isEmpty)<br />    if(nonEmpty.length==0)<br />      Stream.empty[Int]<br />    else {<br />      val (low,high) = nonEmpty.<br />        map(_.head).zipWithIndex.<br />          partition(t => up && t._1 < last || !up && t._1 > last)<br />      val (e,i) = (if(high.length>0) high else low).minBy(_._1)<br />      e #:: loop(e, nonEmpty.updated(i, nonEmpty(i).tail))<br />    }<br />  }<br />  loop(0, (0 until N).map(n => Reader(prefix + "-" + phase + "-" + n)))<br />}<br /></pre>Let's walk through. Again the stream is recursive. It starts with a collection of Readers set to right files. Then in each step you filter out empty stream(tracks with no more elements) and partition them according to the last element(in the argument). If there are higher you take their minimum else you take the minimum of lower. And loop with passing on the read element and a new collection - non empty streams with the read one advanced by one element.<br /><br />Writer was a bit trickier. It needs internal state, but I prohibited mutable state. Solution is to return a new Writer containing a new state every time you write. Then the user must just be careful not to use stale Writers - not that big a deal.<br />This is the Writer trait<br /><pre>trait Writer{<br />  def write(num: Int): Writer<br />  def moreThanOneUsed: Boolean<br />}</pre>Very simple interface. And here's the recursive constructor function<br /><pre>def Writer(prefix: String, phase: Int, N: Int, up: Boolean): Writer = {<br />  val tracks = (0 until N).map(<br />  n => new PrintWriter(<br />    new BufferedWriter(<br />      new FileWriter(prefix+"-"+phase+"-"+n))))<br />  def mkWriter(i: Int, last: Int, used: Boolean): Writer = new Writer{<br />    def write(num: Int) = {<br />      val (ni,nu) =<br />        if (up && num < last || !up && num > last)<br />          ((i + 1) % tracks.length, true)<br />        else (i, used)<br />      tracks(ni).print(num)<br />      tracks(ni).print(' ')<br />      tracks(ni).flush()<br />      mkWriter(ni, num, nu)<br />    }<br />    def moreThanOneUsed = used<br />  }<br />  mkWriter(0, if (up) Integer.MIN_VALUE else Integer.MAX_VALUE, used=false)<br />}<br /></pre>Creates all the tracks to be put in the closure. First writer has the proper start value then every next is constructed like this: figure out the new values for track number and 'used'(the long if) then actually write out and return a new writer encapsulating track number and 'used'. Since these writers are quite lightweight garbage collection pressure shouldn't be a problem. Especially since the whole process is bound by I/O. Anyway you could optimize by creating all possible states in advance and just passing a new reference each time.<br /><br />Putting it all together.<br /><pre>def loop(i: Int, source: Stream[Int]){<br />  val sink = source.foldLeft(Writer(prefix, i, N, up))(_ write _) <br />  if (sink.moreThanOneUsed) loop(i+1, MultiReader(prefix, i, N ,up))<br />}<br />loop(0, Reader(inName))<br /></pre>So you take an input stream, fold it over a writer writing in each step. And if you used more than one track you repeat with a new input stream.<br />I find this solution to be MUCH MORE elegant. Not to mention it's just 65 lines of scala. But it makes me really sad they don't even mention <a href="http://en.wikipedia.org/wiki/Functional_programming" rel="wikipedia" target="_blank" title="Functional programming">functional programming</a> at algorithms course. I'm probably gonna pay the professor and TA's a visit in near future.<br /><div style="margin-top: 20px; overflow: hidden;">