<!doctype html><html><head><title>Cool Monday - Hindley-Milner on a dynamic language</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><link rel=stylesheet href=/scss/main.min.31cac6fb291c18037123c54900f92aaa75653b03bf9d6b70a2fd0565930494e3.css media=screen></head><body><div class=nav><a href=/><h2 class=title>Andraž Bajt's blog</h2></a><div class=nav-sub><a class=nav-item href=/about>About Me</a>
<a class=nav-item href=/>Archive</a></div><div class=nav-sub-right><a class=nav-icon href=https://github.com/edofic target=_blank><img src=/icons/github.svg width=20></a>
<a class=nav-icon href=https://www.linkedin.com/in/edofic target=_blank><img src=/icons/linkedin.svg width=20></a>
<a class=nav-icon href=https://twitter.com/edofic target=_blank><img src=/icons/twitter.svg width=20></a>
<a class=nav-icon href=/index.xml target=_blank><img src=/icons/rss.svg width=20></a>
<a class=nav-icon href=mailto:blog@edofic.com target=_blank><img src=/icons/email.svg width=20></a></div></div><hr><div class=main><h1>Cool Monday - Hindley-Milner on a dynamic language</h1><time>2012-11-05</time><hr><p>So I&rsquo;m getting into type theory. Slowly. Note to self: read a proper
book on this topic. I&rsquo;m getting familiar with it through some practical
applications. Namely scala and haskell. </p><p>That same <a href=/posts/2012-10-29-design-patterns-bullshit>discussion about design
patterns</a> also
included dynamic vs <a href=http://en.wikipedia.org/wiki/Type_system title="Type system">static
typing</a>. And I
asked twitter about it. <a href=https://twitter.com/HairyFotr>HairyFotr</a> linked
this <a href=http://screencasts.chariotsolutions.com/uncovering-the-unknown-principles-of-type-inference->amazing talk about type
inference</a>
to me. Basically there are two conclusions to be drawn</p><ul><li>Every static typed language should have at least limited type
<a href=http://en.wikipedia.org/wiki/Inference title=Inference>inference</a>.
It&rsquo;s compiler&rsquo;s job to do so and quite trivial to implement.</li><li>Properly done static typed language provides all features the that
dynamic typed languages can. Safely.</li></ul><p>As I&rsquo;m (still) <a href=/posts/2012-08-29-creating-a-language-1>implementing a
language</a> that
happens to be dynamic(because I was too lazy to look-up how to do type
checking) second point interests me more. </p><p>Can I turn my language into a static one without changing syntax(adding
type annotations) and losing features? That would be awesome!</p><p>After a day of thinking, answer seems to be <strong>YES!</strong></p><h3 id=global-type-inference-in-a-nutshell>Global type inference in a nutshell</h3><p>So I want a dynamic-like syntax(no types anywhere). Good news is I don&rsquo;t
have nominal types, so I can use inference to get structural types. </p><p>Java, C# and many other mainstream languages use <a href=http://en.wikipedia.org/wiki/Nominative_type_system title="Nominative type system">nominal
typing</a>
at the level of the vm. This means that type A is a subtype of type B
precisely when name of A is a subtype of name ob B. For example </p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Foo</span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>method</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Bar</span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>method</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> b<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></td></tr></table></div></div><p>If you have a method that takes in an instance of Foo, you cannot pass
an instance of Bar. Because Bar isn&rsquo;t subtype of Foo. Even though they
are <a href=http://en.wikipedia.org/wiki/Structure title=Structure>structurally</a>
the same. Fun fact: because
<a href=http://en.wikipedia.org/wiki/Java_Virtual_Machine title="Java Virtual Machine">JVM</a>
is designed like this, scala cannot have global type inference.
See, global inference(or &ldquo;<a href=http://en.wikipedia.org/wiki/Type_inference title="Type inference">type
reconstruction</a>")
looks at usages and reconstructs properties and structure.  Another
example</p><pre><code>a = b.c + 1
</code></pre><p>That would be legal scrat code(or python, ruby or many other things).
You take b&rsquo;s property named c, add one to it and assign the result to a.
So b must have property c. That&rsquo;s the first structural requirement. From
the + operator you can see that this c must be numeric. And from this
follows that a is also numeric as it&rsquo;s the result of this computation.
If this were a body of a method and b it&rsquo;s parameter, type requirement
for be would be(in made up syntax) <code>b: { c: Number }</code> - object with member
of Number type. But that doesn&rsquo;t give you no class names.
So why is this <strong>global</strong>inference? It goes through the whole block of
code(usually a function body) and puts in stub types where it doesn&rsquo;t
have enough info and then solves the system of
<a href=http://en.wikipedia.org/wiki/Requirement title=Requirement>requirements</a>
and substitutes back.</p><h3 id=possible-problems>Possible problems</h3><p>First of all, I have objects. This means I have to reconstruct object
structure. This shouldn&rsquo;t be too bad. And you can quite easily figure
out that A is subtype of B if set of requirements for A is a superset of
requirements for B. </p><p>Then there&rsquo;s &ldquo;mutable types&rdquo;. I concluded that following code should be
illegal</p><pre><code>a = 1
a = &quot;two&quot;
</code></pre><p>as type of a should remain the same as in first assignment. This lets
you reason about the code much more. But there&rsquo;s a hidden mutability. I
use regular functions as object constructors returning a keyword &ldquo;this&rdquo;
that evaluates to current scope. But throughout the body you still
access this scope and it&rsquo;s type(it&rsquo;s an object after all) changes with
every new (first) assignment and function definition. But this should be
tracked through all possible code paths. Only problem is an if
expression. Type of an if(and it&rsquo;s side-effects) can only be common
super type of both then and else branch - an intersection of requirement
sets. In a dynamic language you can reason about conditions and conclude
when something should definitely be in scope and use it. Automatic
reasoning about conditions? This could turn out tricky. Perhaps in later
implementation.
An there&rsquo;s third an final problem(that I can see). Infinite types. I
have not seen a practical usage but it doesn&rsquo;t work and that bothers me.
Dynamic code in scrat just works, but same code translated to haskell
yields a compiler error - &ldquo;can&rsquo;t instantiate infinite type&rdquo;. But
apparently infinite types can be detected, so maybe I can find a way to
present them and it will compile.</p><h3 id=conclusion>Conclusion</h3><p>There are some problems but I believe I can make it work. It would be
super awesome to have a language that feels dynamic but gives you all
benefits of static typing. Compilers should do the hard work after all!
And they should be capable of inferring general enough types that all
correct programs type check.
Or am I missing some important aspect that works only with dynamic
types?</p><hr><p>Last modified on 2012-11-05</p><a href=/posts/2012-11-02-web-framework/>Previous Hunt for a web framework that works</a><br><a href=/posts/2012-11-12-scala-macros/>Next Cool Monday - Scala Macros</a></div></body></html>