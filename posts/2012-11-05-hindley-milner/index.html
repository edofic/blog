<!doctype html><html><head><title>Cool Monday - Hindley-Milner on a dynamic language</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.3bdd3e0bba961aa48fdce1402e6f01783c435b4dfb0025c8d0022ddaea0f3d19.css media=screen><script src=/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>My Programming Escapades</div><div class=nav-subtitle>Andraz Bajt</div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>My Programming Escapades</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>My Programming Escapades</div><div class=single-column-header-subtitle>Andraz Bajt</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Cool Monday - Hindley-Milner on a dynamic language<div class=post-meta><time itemprop=datePublished>2012-11-05</time></div></div></div><div class=post-body-wrapper><div class=post-body><p>So I&rsquo;m getting into type theory. Slowly. Note to self: read a proper
book on this topic. I&rsquo;m getting familiar with it through some practical
applications. Namely scala and haskell. </p><p>That same <a href=/posts/2012-10-29-design-patterns-bullshit>discussion about design
patterns</a> also
included dynamic vs <a href=http://en.wikipedia.org/wiki/Type_system title="Type system">static
typing</a>. And I
asked twitter about it. <a href=https://twitter.com/HairyFotr>HairyFotr</a> linked
this <a href=http://screencasts.chariotsolutions.com/uncovering-the-unknown-principles-of-type-inference->amazing talk about type
inference</a>
to me. Basically there are two conclusions to be drawn</p><ul><li>Every static typed language should have at least limited type
<a href=http://en.wikipedia.org/wiki/Inference title=Inference>inference</a>.
It&rsquo;s compiler&rsquo;s job to do so and quite trivial to implement.</li><li>Properly done static typed language provides all features the that
dynamic typed languages can. Safely.</li></ul><p>As I&rsquo;m (still) <a href=/posts/2012-08-29-creating-a-language-1>implementing a
language</a> that
happens to be dynamic(because I was too lazy to look-up how to do type
checking) second point interests me more. </p><p>Can I turn my language into a static one without changing syntax(adding
type annotations) and losing features? That would be awesome!</p><p>After a day of thinking, answer seems to be <strong>YES!</strong></p><h3 id=global-type-inference-in-a-nutshell>Global type inference in a nutshell</h3><p>So I want a dynamic-like syntax(no types anywhere). Good news is I don&rsquo;t
have nominal types, so I can use inference to get structural types. </p><p>Java, C# and many other mainstream languages use <a href=http://en.wikipedia.org/wiki/Nominative_type_system title="Nominative type system">nominal
typing</a>
at the level of the vm. This means that type A is a subtype of type B
precisely when name of A is a subtype of name ob B. For example </p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Foo</span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>method</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Bar</span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>method</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> b<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>If you have a method that takes in an instance of Foo, you cannot pass
an instance of Bar. Because Bar isn&rsquo;t subtype of Foo. Even though they
are <a href=http://en.wikipedia.org/wiki/Structure title=Structure>structurally</a>
the same. Fun fact: because
<a href=http://en.wikipedia.org/wiki/Java_Virtual_Machine title="Java Virtual Machine">JVM</a>
is designed like this, scala cannot have global type inference.
See, global inference(or &ldquo;<a href=http://en.wikipedia.org/wiki/Type_inference title="Type inference">type
reconstruction</a>")
looks at usages and reconstructs properties and structure.  Another
example</p><pre><code>a = b.c + 1
</code></pre><p>That would be legal scrat code(or python, ruby or many other things).
You take b&rsquo;s property named c, add one to it and assign the result to a.
So b must have property c. That&rsquo;s the first structural requirement. From
the + operator you can see that this c must be numeric. And from this
follows that a is also numeric as it&rsquo;s the result of this computation.
If this were a body of a method and b it&rsquo;s parameter, type requirement
for be would be(in made up syntax) <code>b: { c: Number }</code> - object with member
of Number type. But that doesn&rsquo;t give you no class names.
So why is this <strong>global</strong>inference? It goes through the whole block of
code(usually a function body) and puts in stub types where it doesn&rsquo;t
have enough info and then solves the system of
<a href=http://en.wikipedia.org/wiki/Requirement title=Requirement>requirements</a>
and substitutes back.</p><h3 id=possible-problems>Possible problems</h3><p>First of all, I have objects. This means I have to reconstruct object
structure. This shouldn&rsquo;t be too bad. And you can quite easily figure
out that A is subtype of B if set of requirements for A is a superset of
requirements for B. </p><p>Then there&rsquo;s &ldquo;mutable types&rdquo;. I concluded that following code should be
illegal</p><pre><code>a = 1
a = &quot;two&quot;
</code></pre><p>as type of a should remain the same as in first assignment. This lets
you reason about the code much more. But there&rsquo;s a hidden mutability. I
use regular functions as object constructors returning a keyword &ldquo;this&rdquo;
that evaluates to current scope. But throughout the body you still
access this scope and it&rsquo;s type(it&rsquo;s an object after all) changes with
every new (first) assignment and function definition. But this should be
tracked through all possible code paths. Only problem is an if
expression. Type of an if(and it&rsquo;s side-effects) can only be common
super type of both then and else branch - an intersection of requirement
sets. In a dynamic language you can reason about conditions and conclude
when something should definitely be in scope and use it. Automatic
reasoning about conditions? This could turn out tricky. Perhaps in later
implementation.
An there&rsquo;s third an final problem(that I can see). Infinite types. I
have not seen a practical usage but it doesn&rsquo;t work and that bothers me.
Dynamic code in scrat just works, but same code translated to haskell
yields a compiler error - &ldquo;can&rsquo;t instantiate infinite type&rdquo;. But
apparently infinite types can be detected, so maybe I can find a way to
present them and it will compile.</p><h3 id=conclusion>Conclusion</h3><p>There are some problems but I believe I can make it work. It would be
super awesome to have a language that feels dynamic but gives you all
benefits of static typing. Compilers should do the hard work after all!
And they should be capable of inferring general enough types that all
correct programs type check.
Or am I missing some important aspect that works only with dynamic
types?</p><hr width=100%><p style=color:#777>Last modified on 2012-11-05</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2012-11-12-scala-macros/>Next<br>Cool Monday - Scala Macros</a>
<a class=older-posts href=/posts/2012-11-02-web-framework/>Previous<br>Hunt for a web framework that works</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div><script src=/js/journal.js></script></body></html>