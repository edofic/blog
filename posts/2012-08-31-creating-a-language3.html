---
title: Making a programming language: Part 3 - adding features
---

<a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" target="_blank">Table of contents</a>, <a href="https://github.com/edofic/scrat-lang" target="_blank">Whole project on github</a><br /><br />So now I have a repl that can evaluate stuff like<br /><pre>(2+3)*(7/2-1)</pre>Not much of a <a href="http://en.wikipedia.org/wiki/Programming_language" rel="wikipedia" target="_blank" title="Programming language">programming language</a> - more like a calculator, and not even a good one. Lets add some features!<br /><br /><h3>Constants</h3><div>Like pi, e and such. I have to change the grammar to match identifiers to.</div><div>Now I have</div><pre>private def factor: Parser[Expression] = number | ("(" ~> expr <~ ")")</pre><div><br />And I change that to</div><pre>private def factor: Parser[Expression] = value | parenExpr <br /><br />private def value: Parser[Expression] = number | identifier<br /><br />private def identifier: Parser[Identifier] = "[a-zA-Z]\\w*".r ^^ {<br />  s => Identifier(s)<br />}</pre>and I also added a new token type<br /><pre>case class Identifier(id: String) extends Expression</pre><br />and enabled this in evaluator<br /><pre>case Identifier(name) => {<br />  StdLib(name) match {<br />    case Some(v: Double) => v<br />  case _ => throw new SemanticError(name + " not found")<br />  }<br />}</pre>StdLib is just a map object. I went the python way - variables(and constants) are entries in a global dictionary. Just a decision I made whil implementing this. As I said, I don't have a plan, I don't know what I'm doing and I don't know how stuff is done. How hard can it be?! (<a href="http://www.bbc.co.uk/topgear/" rel="homepage" target="_blank" title="Top Gear (2002 TV series)">Top Gear</a> anyone?)<br /><br /><h3>Exponentiation</h3><div>Another math feature. It's more of a test for myself to see if I understand grammars. Especially how to make a grammar not <a href="http://en.wikipedia.org/wiki/Left_recursion" rel="wikipedia" target="_blank" title="Left recursion">left-recursive</a>. Because apparently such grammars don't work with <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser" rel="wikipedia" target="_blank" title="Recursive descent parser">RDP</a>. I turned out I don't understand grammars.</div><pre>private def exponent: Parser[Expression] = (value | parenExpr) ~ "^" ~ (value | parenExpr) ^^ {<br />  case a ~ "^" ~ b => Exponent(a,b)<br />}<br /><br />private def factor: Parser[Expression] = (value ||| exponent) | parenExpr<br /></pre><div><br />The ||| operator is an ugly hack. It tries both sides and returns the longer match. By the time I was writing this I didn't know that order is importat. If I just wrote exponent | value it would have worked, because expoenent would match a value anyway and then failed on missing ^.<br /><br />Token and evaluation(uses math.pow) for this are quite trivial.<br /><br /><h3>Function calls</h3></div><pre>case class ExpList(lst: List[Expression]) extends Expression<br />case class FunctionCall(name: Identifier, args: ExpList) extends Expression</pre><div>Simple: function call is a name and list of expressions to evaluate for arguments(wrapped because even an expression list is an expression):<br /><br />Parser:<br /><pre>private def arglist: Parser[ExpList] = "(" ~> list <~ ")"<br /><br />private def functionCall: Parser[FunctionCall] = identifier ~ arglist ^^ {<br />  case id ~ args => FunctionCall(id, args)<br />}<br /><br />private def value: Parser[Expression] = number | (identifier ||| functionCall)</pre>Again, I was having trouble - parser just didn't work and resorted to |||. functionCall should come before identifier.<br /><br />Evaluating this is more interesting. I decided to make functions be values too for obvious reasons -> <a href="http://en.wikipedia.org/wiki/Higher-order_function" rel="wikipedia" target="_blank" title="Higher-order function">higher order functions</a>(I'm into functional programming, remember?). So function values must be stored in same "namespace". StdLib(the only "namespace") required to become of type Map[String,Any]. I will have to do pattern matching anyway since this will be dynamic-typed language. (Yes this is a plan, I think it's easier to implement. <a href="http://en.wikipedia.org/wiki/Type_system" rel="wikipedia" target="_blank" title="Type system">Static typing</a> ftw, but that's next project). And I needed a type for function values to pattern match on - I went with Any=>Any and sending in List(arg0,arg1,...) doing more pattern matching inside the function. Will be slow but hey...dynamic typing!<br /><br />from evaluator<br /><pre>case FunctionCall(name, args) => {<br />  StdLib(name.id) match {<br />    case Some(f: FunctionVarArg) => f.apply(apply(args))<br />    case None => throw new ScratSemanticError("function " + name + "not found")<br />  }<br />}</pre><br />and and example function in StdLib<br /><pre>type FunctionVarArg = Any => Any<br /><br />lazy val ln: FunctionVarArg = {<br />  case (d: Double) :: Nil => math.log(d)<br />  case other => throw ScratInvalidTypeError("expected single double but got " + other)<br />}</pre><br /></div><h3>Conclusion</h3><div>As clearly illustrated above, not planning your grammar results in constant changes in many places. So if you're doing something serious just make the whole fricking grammar on a whiteboard beforehand. Seriously. </div><div><br />Anyway..now I still only have a calculator, but a much more powerful one. I can write expressions like <br /><pre>e^pi<br />ln(10+2)<br />1+2*3/4^5-log(e)<br /></pre>But that's nearly not enough. I want to be Touring-complete an ideally to be able to compile/interpret itself.<br /><br /></div><div><b>next: <a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-4.html" target="_blank">Hello World(strings, printing and interpreter)</a></b></div>