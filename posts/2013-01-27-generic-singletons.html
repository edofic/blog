---
title: Generic singletons through dependent method types
--- 

Ever tried to write a <a class="zem_slink" title="Generic programming" href="http://en.wikipedia.org/wiki/Generic_programming" target="_blank" rel="wikipedia">generic</a> singleton? It's an oxymoron of a sort. But sometimes my brain dreams up funny concepts to solve the problem at hand. Sadly I cannot remember what I wanted to use them for. Anyway I think I just made all the <a class="zem_slink" title="Method (computer programming)" href="http://en.wikipedia.org/wiki/Method_%28computer_programming%29" target="_blank" rel="wikipedia">methods</a> generic and solved it this way. But this doesn't really express the notion of one entity that's agnostic to type of the parameters. With generic methods you get a bunch of disconnected units - at least that's the picture in my head.
<h1>General</h1>
[caption id="" align="alignright" width="240"]<a href="http://www.flickr.com/photos/8324353@N05/6857158741" target="_blank"><img class="zemanta-img-inserted zemanta-img-configured" title="Challenge Accepted!" alt="Challenge Accepted!" src="http://farm8.static.flickr.com/7192/6857158741_a4e3d23649_m.jpg" width="240" height="180" /></a> Challenge Accepted! (Photo credit: pierreee)[/caption]

So we've established that generic singletons are just a silly idea, now let's try to implement it - you know "Challenge accepted!" style.
<pre lang="scala">object Singleton[A] { //error: ';' expected but '[' found.
  def id(a:A) = a
}</pre>
Luckily this naive approach does not compile. Try it.
<pre lang="scala">class Singleton[A]{
  def id(a: A) = a 
}

def Singleton[A] = new Singleton[A]</pre>
But this is not a singleton anymore as there is a new instance created everytime.
<pre lang="scala">object Singleton{
  class Instance[A] private[Singleton] (){
    def id(a: A) = a 
  }

  private[Singleton] val cache = 
    collection.mutable.HashMap[Class[_],Instance[_]]()
  def apply[A]()(implicit m: Manifest[A]) = 
    cache.getOrElseUpdate(m.erasure, new Instance[A]).asInstanceOf[Instance[A]]
}

//use as
Singleton[Int].id(1)

//and some sugar
def singleton[A:Manifest] = Singleton[A]()

//now use like
singleton[String].id("hi")</pre>
Didn't bother with <a class="zem_slink" title="Thread safety" href="http://en.wikipedia.org/wiki/Thread_safety" target="_blank" rel="wikipedia">thread safety</a>. And dragging around Manifest just for caching is a bit of a pain, luckily elevated by context bounds.
<h1>Type specific</h1>
That worked for classes that don't bother about the generic types...what if we want specific behavior per type? <a class="zem_slink" title="Type class" href="http://en.wikipedia.org/wiki/Type_class" target="_blank" rel="wikipedia">Type classes</a>. (I mentioned that <a title="Learning Scalaz part 1" href="http://www.edofic.com/2013/01/learning-scalaz-part-1/" target="_blank">once</a>). A trait for general interface and objects for specific types. Magic lies in making these objects implicit and having a method that gives you the right one!
<pre lang="scala">trait Singleton[A]{
  def f(a: A): A
}

implicit object IntSingleton extends Singleton[Int]{
  def f(n: Int) = n + 1
}

implicit object StringSingleton extends Singleton[String]{
  def f(s: String) = "Hello " + s
}

def Singleton[A](implicit s: Singleton[A]) = s

Singleton[Int].f(1) // == 2</pre>
<h1>Specific functionality</h1>
Now let's add a little twist.
<pre lang="scala">implicit object IntSingleton extends Singleton[Int]{
  def f(n: Int) = n + 1
  def g(n: Int) = n - 1
}

//this line doesn't compile
Singleton[Int].g(1)</pre>
and it doesn't compile for a reason. <a class="zem_slink" title="Type system" href="http://en.wikipedia.org/wiki/Type_system" target="_blank" rel="wikipedia">Static type</a> of returned from Singleton[Int] is Singleton[Int]. And there is no method g defined in trait Singleton. But we are sure it exists. We could call IntSingleton directly but this makes whole Singleton abstraction worthless. Luckily for us scala 2.10 has a feature called method <a class="zem_slink" title="Dependent type" href="http://en.wikipedia.org/wiki/Dependent_type" target="_blank" rel="wikipedia">dependent types</a>. To my best understanding this means support for return types that depend on the type of parameters. And here we want the type to reflect which instance is being returned. Nothing suits the job better as singleton types. Singleton type is a type that has only one value. So an object A will be of type A.type. This type is worthless for inference but great when you're doing the type tags. We just need a little fix
<pre lang="scala">def Singleton[A](implicit s: Singleton[A]): s.type = s</pre>
This method will return the correct instance along with it's type while giving you a nice abstraction of <a class="zem_slink" title="Type constructor" href="http://en.wikipedia.org/wiki/Type_constructor" target="_blank" rel="wikipedia">type constructor</a>.

&nbsp;
