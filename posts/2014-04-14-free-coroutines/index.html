<!doctype html><html><head><title>Coroutines for free</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.3bdd3e0bba961aa48fdce1402e6f01783c435b4dfb0025c8d0022ddaea0f3d19.css media=screen><script src=/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>My Programming Escapades</div><div class=nav-subtitle>Andraz Bajt</div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>My Programming Escapades</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>My Programming Escapades</div><div class=single-column-header-subtitle>Andraz Bajt</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Coroutines for free<div class=post-meta><time itemprop=datePublished>2014-04-14</time></div></div></div><div class=post-body-wrapper><div class=post-body><h3 id=motivation>Motivation</h3><p>My first run-in with coroutines was with Python's generators.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ints</span>():
    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>while</span> True:
        <span style=color:#66d9ef>yield</span> i
        i <span style=color:#f92672>+</span><span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</code></pre></div><p>This is a function that never returns. Instead it runs in an infinite loop over all natural numbers. But it <em>yield</em>s every number. This means it actually stops and &ldquo;returns&rdquo; the number to the caller but is available for more execution. Kind-of like implementing an <code>Iterator</code> but the control flow is reversed. Now you don't produce a value on demand but rather you run and output values at will while the runtime system stops and resumes you.</p><p>Now if you would happen to invent <code>yield</code> how would you implement it? I think I would hack up the runtime. I would add support for suspending a function. Effectively creating delimited continuations. A function could request that it current scope(and &ldquo;program counter&rdquo;) be stored on the heap. I personally find this a bit nasty. Even more so in a statically compiled language.</p><h3 id=monads-to-the-rescue>Monads to the rescue</h3><p>This <code>yield</code> is in its essence an effect. Monads are a way to implement effects. Let's try to use them to create <em>suspendable computations</em>. But let's start with something simpler and work our way up.</p><h3 id=trampolines-for-free>Trampolines for free</h3><p>A <a href=http://en.wikipedia.org/wiki/Trampoline_(computing)>trampoline</a> is a system to implement function calls effectively trading stack for heap. This allows for some nifty tricks like implementing a tail recursion in a system that doesn't optimize for it or doing deep recursive calls that would otherwise result in a stack overflow. In Haskell it just provides explicit boundary between results and thunks.</p><p>This is quite trivial to implement. Consider this definition.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Trampoline</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Return</span> a <span style=color:#f92672>|</span> <span style=color:#66d9ef>Bounce</span> (<span style=color:#66d9ef>Trampoline</span> a)

<span style=color:#a6e22e>runTrampoline</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Trampoline</span> a <span style=color:#f92672>-&gt;</span> a
<span style=color:#a6e22e>runTrampoline</span> (<span style=color:#66d9ef>Return</span> a) <span style=color:#f92672>=</span> a
<span style=color:#a6e22e>runTrampoline</span> (<span style=color:#66d9ef>Bounce</span> t) <span style=color:#f92672>=</span> runTrampoline t
</code></pre></div><p>Function <code>a -> b</code> now becomes <code>a -> Trampoline b</code>. It can wrap up its result in a <code>Return</code> or bounce by wrapping up a thunk(Haskell is non-strict!) in a <code>Bounce</code>. <code>runTrampoline</code> is implemented with tail recursion but could be done with a <code>while</code> loop in languages that don't optimize it.</p><p>But now comes the important trick! Consider the <code>Free</code> monad from package <code>free</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Free</span> f a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Pure</span> a <span style=color:#f92672>|</span> <span style=color:#66d9ef>Free</span> (f (<span style=color:#66d9ef>Free</span> f a))
</code></pre></div><p>This looks very similar but with an additional layer <code>f</code> - a functor. Using the <code>Identity</code> functor we can very simply implement the trampoline.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Trampoline</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> <span style=color:#66d9ef>Identity</span>

<span style=color:#a6e22e>bounce</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Trampoline</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Trampoline</span> a
<span style=color:#a6e22e>bounce</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> <span style=color:#f92672>.</span> <span style=color:#66d9ef>Identity</span>

<span style=color:#a6e22e>runTrampoline</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Trampoline</span> a <span style=color:#f92672>-&gt;</span> a
<span style=color:#a6e22e>runTrampoline</span> <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>.</span> retract
</code></pre></div><p>And we get a trampoline for free! Also a <code>Monad</code> and <code>Applicative</code> instances(and more) that make composition of trampoline-using code very easy. This would else require some boilerplate code. I've also included a utility function <code>bounce</code> that is now analogous to the <code>Bounce</code> constructor from before.</p><p>If the underlying functor is a monad too(which <code>Identity</code> is) <code>Free</code> knows how to collapse itself - we get <code>runTrampoline</code> for free.</p><h3 id=generators>Generators</h3><p>Finally! Keeping trampolines in mind let think about generators. We could write one as a normal function but with explicit notion of <em>generator</em> in the return type. A generator function return a signal that it's done or a value and the next generator function - continuation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Producer</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Done</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Yield</span> a (<span style=color:#66d9ef>Producer</span> a)
</code></pre></div><p>Again we see structure similar to <code>Free</code>. And in fact we can implement this with <code>Free</code> if use use the <code>((,) a)</code> functor. What is this cryptic type signature? It's a tuple with one missing type parameter. Think of it like <code>(a,)</code>. We fix the first member and our <code>Functor</code> instance maps over the second member.</p><p>But there's an additional catch. When we're done we don't return anything but <code>Pure</code> has a parameter <code>a</code>. We just fix this to <code>()</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Producer</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> ((,) a) ()

<span style=color:#a6e22e>yield</span> <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Producer</span> a
<span style=color:#a6e22e>yield</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> (a, return ())
</code></pre></div><p>The <code>yield</code> function only takes a value, it doesn't know about the continuation, it always users <code>return ()</code> which is essentially &ldquo;I'm done&rdquo;. But if we use monadic(or applicative) style we can substitute it with our continuation - the function passed to bind.</p><p>But before looking at an example let's look at the original definition(the one without <code>Free</code>) again. It looks a lot like list! In fact it's exactly the same. This means we can simply convert to list just by substituting constructors.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>consumeProducer</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Producer</span> a <span style=color:#f92672>-&gt;</span> [a]
<span style=color:#a6e22e>consumeProducer</span> (<span style=color:#66d9ef>Pure</span> ()) <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
<span style=color:#a6e22e>consumeProducer</span> (<span style=color:#66d9ef>Free</span> (a, c)) <span style=color:#f92672>=</span> a <span style=color:#66d9ef>:</span> consumeProducer c
</code></pre></div><p>This is exactly the thing <code>Free</code> is meant to do. We described our computation in a pure way and then written an interpreter.</p><p>Now the promised example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>producerExample</span> <span style=color:#f92672>=</span> consumeProducer <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
  yield <span style=color:#ae81ff>1</span>
  yield <span style=color:#ae81ff>2</span>
  yield <span style=color:#ae81ff>3</span>
</code></pre></div><p>The semantics is quite trivial and you should immediately see this produces <code>[1,2,3]</code>. More importantly it inverts the control allowing us to do arbitrary computations(like recursion) between yields.</p><p>In fact we even did better than Python! Inside a <code>Producer</code> you can call to other producers. And they can yield directly! No need for nasty loops like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> helper_function():
    <span style=color:#66d9ef>yield</span> e
</code></pre></div><p>You just write</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>helper_function</span>
</code></pre></div><p>But we also did worse. This approach does not allow for any other effects inside producers. This can be easily mitigated using transformers. But I'll show this in another post.</p><h3 id=consumers>Consumers</h3><p>What if we don't want to convert our producers to list but just consume them immediately? We need some sort of consumers.</p><p>I'll skip a few steps of reasoning and jump straight to the conclusion. We can use the same approach. A consumer is just a function that returns a result or a continuation that takes a value and returns another consumer. This means it can consume an arbitrary amount of values and stop when it wants. It's very similar to folding but with the added control of stopping. Again we inverted the control. It's usually the fold that controls the &ldquo;looping&rdquo; not the function we pass into the fold. This concept is called an <em>iteratee</em>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Consumer</span> a b <span style=color:#f92672>=</span> <span style=color:#66d9ef>Result</span> b <span style=color:#f92672>|</span> <span style=color:#66d9ef>Await</span> (a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Consumer</span> a b)
</code></pre></div><p>And yet again we see the familiar structure. And yet again our functor is a bit funky: <code>((->) a)</code>. It's a function that takes a known parameter but we map over it's result. Think of <code>a -> </code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Consumer</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> ((<span style=color:#f92672>-&gt;</span>) a)

<span style=color:#a6e22e>await</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Consumer</span> a a
<span style=color:#a6e22e>await</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Free</span> return
</code></pre></div><p>The <code>await</code> function might me a bit unintuitive at first. But take a close look at it's type signature. It consumes <code>a</code>s and produces an <code>a</code>. And it seems reasonable to say it should consume exactly one <code>a</code> and then return it. And that's exactly what it does. Function <code>return</code> takes one element and packs it up into a <code>Pure</code> completing our consumer.</p><p>Then we use monadic(or applicative as I'll show) style to consume more than one.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(<span style=color:#f92672>+</span>) <span style=color:#f92672>&lt;$&gt;</span> await <span style=color:#f92672>&lt;*&gt;</span> await
</code></pre></div><p>This consumes two values and returns their sum.</p><p>Now we could feed it a list(being dual to our producers) but I'll skip this and write a more interesting function. One that feeds a producer into a consumer. The code for feeding a list is almost exactly the same and you should try to write it as an exercise.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>pipe</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Producer</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Consumer</span> a r <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> r
<span style=color:#a6e22e>pipe</span> <span style=color:#66d9ef>_</span> (<span style=color:#66d9ef>Pure</span> r) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> r
<span style=color:#a6e22e>pipe</span> (<span style=color:#66d9ef>Free</span> (a, c)) (<span style=color:#66d9ef>Free</span> f) <span style=color:#f92672>=</span> pipe c <span style=color:#f92672>$</span> f a
<span style=color:#a6e22e>pipe</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</code></pre></div><p>What's going here?</p><ul><li>If our consumer is done we're done too.</li><li>If producer is yielding and consumer is awaiting we feed that value into consumers continuation and recurse.</li><li>Else it's not possible to continue.</li></ul><p>And now we can directly consume. But one problem remains. We cannot compose <code>Producer</code> and <code>Consumer</code> together and get something composable again. We get a <code>Maybe</code>. I argue that is is a smell of bad design. We should be able to compose again and again as this will greatly simplify the design of the system using these components. It turns out we can do this but since this is getting a bit long I'll cover this topic in another post.</p><hr width=100%><p style=color:#777>Last modified on 2014-04-14</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2014-05-03-ghc-arch-static/>Next<br>Static linking with GHC on ArchLinux</a>
<a class=older-posts href=/posts/2014-03-07-practical-future-option/>Previous<br>Practical Future[Option[A]] in Scala</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div><script src=//js/journal.js></script></body></html>