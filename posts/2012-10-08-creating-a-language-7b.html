---
title: Making a programming language: Part 7b - using objects
---

<a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Table of contents</a><span style="background-color: white; color: #222222; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;">, </span><a href="https://github.com/edofic/scrat-lang" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Whole project on github</a><br /><br />Something like EPIC FAIL occured to me and I <a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-7.html" target="_blank">published a post</a> containing only half the content I intended to write. So I'm doing a part b.<br /><br />My intended usage of objects is something along the lines of <br /><pre>objectName.someProperty<br />objectName.someFunction()<br />someFunction().someProperty<br />someObject.someProperty.someFunction().someProperty.someFunction<br /></pre>Explanation<br /><br /><ol><li>getting a value from an <a href="http://en.wikipedia.org/wiki/Object_%28computer_science%29" rel="wikipedia" target="_blank" title="Object (computer science)">object</a></li><li>invoking a function contained in an object</li><li>getting a value from returned object of the invoked function</li><li>a bit contrived example. Invoking a function contained inside a property(object) of an object and then getting a <a href="http://en.wikipedia.org/wiki/Function_%28mathematics%29" rel="wikipedia" target="_blank" title="Function (mathematics)">function value</a> from a property of the returned value from the first function. That's a mouthful, just read the damn code instead</li></ol><h3>Dot access</h3><div>So everything bases on those little dots. First my thoughts were something like "you just do expr <- expr | expr.expr". This is just wrong. At least I should have reversed the order as this leads to infineite <a href="http://en.wikipedia.org/wiki/Left_recursion" rel="wikipedia" target="_blank" title="Left recursion">left recursion</a>. Then I might have got away. Then I realized I only need dots after function calls and simple identifiers. Design choice(if you think it's a bad one leave a comment). Notice the "simple <a href="http://en.wikipedia.org/wiki/Identifier" rel="wikipedia" target="_blank" title="Identifier">identifier</a>". That's what I did: Renamed identifier to simple identifier and put something that handles dots under name identifier. And then fixed everything. </div><pre>case class DotAccess(lst: List[Expression]) extends Expression<br /><br />private def identifier: Parser[DotAccess] = <br />  rep1sep((functionCall | simpleIdentifier), ".") ^^ DotAccess.apply<br /></pre><div>That's about it. At least for parsing. Now the fun begins.<br /><h3>Nesting scopes</h3></div><div>Scopes were designed with nesting in mind. This is a double edged sword. See, the "privates" can be  done if you rely on not being able to access the parent scope. If dot access exposes full addressing functionality a powerful feature ceases to exist. So some protection should me in place. Something like strict get</div><pre>class SScope ...<br /> def getStrict(key: String): Option[Any] = map.get(key)<br />...<br /></pre><div>And I also added an unlinked view to it just to ease usage. This is just a method that returns new SScope with no parent overriding getters and put to use map available in closure.<br />So now I can walk down the list in DotAccess recursively and explicitly override the implicit scope parameter. And everything automagically works. Well, not quite. If you have a function call, the arguments need to be evaluated in top scope. Not in the nested one like the function identifier. At first I didn't even think about this and only failing attempts at more complex recursion brought up this quite obvious bug.<br />So how to solve this? I could pre-evaluate all arguments, but I use recursion to do this and it's two levels(at least) deeper from where dots happen. So no go. I need to carry on the outer scope. I overloaded the apply method from Evaluator so other code can still function(tests ftw!) and all in all it looks like this: <br /><pre>def apply(e: List[Expression])(implicit scope: SScope): <br />    Any = {<br />    (e map apply).lastOption match {<br />      case Some(a) => a<br />      case None => ()<br />    }<br />  }<br /><br />  def apply(e: Expression)(implicit scope: SScope): Any = apply(e, None)(scope)<br /><br />  def apply(e: Expression, auxScope: Option[SScope])(implicit scope: SScope):     Any = e match {<br />    ...<br />    case DotAccess(list) => {<br />      val outerScope = scope<br />      def step(list: List[Expression])(implicit scope: SScope): Any =<br />        list match {<br />        case Nil =>        <br />          throw new ScratInvalidTokenError("got empty list in DotAccess")<br />        case elem :: Nil => apply(elem, Some(scope))(outerScope)<br />        case head :: tail => apply(head) match {<br />          case s: SScope => step(tail)(s.unlinked)<br />          case other => <br />            throw new ScratInvalidTypeError("expected scope, got " + other)<br />        }<br />      }<br />      step(list)<br />  }<br />}<br /></pre>So an optional aux scope is the answer. It doesn't seem pretty to me, but it does the job. </div><div><br /></div><div><b>next: </b><a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-8.html" target="_blank">trying to go faster</a></div><br />