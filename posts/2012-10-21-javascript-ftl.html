---
title: Javascript faster than light! (well C actually)
---

<table cellpadding="0" cellspacing="0" style="float: right; margin-right: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><div><div><div><a href="http://www.flickr.com/photos/42149364@N03/6772086623" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="157/365. Acorn - Oak Nut - The Scrat Problem." border="0" class="zemanta-img-inserted" height="161" src="http://farm8.static.flickr.com/7156/6772086623_646ee6ab31_m.jpg" style="border: none; font-size: 0.8em;" width="240" /></a></div></div></div></td></tr><tr><td style="text-align: center; width: 240px;">157/365. Acorn - Oak Nut - The Scrat Problem. (Photo credit: <a href="http://www.flickr.com/photos/42149364@N03/6772086623" target="_blank">Anant N S (www.thelensor.tumblr.com)</a>)</td></tr></tbody></table>Disclaimer: I never was a fan of js, but I've come to think it's quite AWESOME!<br /><br />Anyway I <a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" target="_blank">invented my own toy language scrat</a> recently. And I now I want it to go fast and do cool stuff. So I went on to compile it. Well more appropriate term would be "<a href="http://en.wikipedia.org/wiki/Translation" rel="wikipedia" target="_blank" title="Translation">translate</a>"(as <a href="https://twitter.com/zidarsk8" target="_blank">zidarsk8</a> pointed out) since my target is <a href="http://en.wikipedia.org/wiki/JavaScript" rel="wikipedia" target="_blank" title="JavaScript">JavaScript</a>. And then I use node.js to run it - browser test sometime in the future. Enough about that, I'll be doing a post when I get everything to run under js.<br /><br />My original purpuse for translation was speed as node uses V8 and that's quite speedy. So I did a quick test. I wrote a simple recursive <a href="http://en.wikipedia.org/wiki/Fibonacci_number" rel="wikipedia" target="_blank" title="Fibonacci number">Fibonacci sequence</a> generator. The cool thing about this is that it takes fib(n) steps to calculate fib(n) but call-stack depth is just n - I don't have loops and I haven't implemented <a href="http://en.wikipedia.org/wiki/Tail_call" rel="wikipedia" target="_blank" title="Tail call">tail call optimization</a> yet.  And then I wrote same thing in js an noticed it's quite a bit faster. Great. Now halfway through <a href="http://en.wikipedia.org/wiki/Implementation" rel="wikipedia" target="_blank" title="Implementation">implementation</a>(more like 80%) I decided to do a real benchmark.<br /><h3>Scrat</h3><div>Here's the source</div><pre>func fib(n) if n<2 then 1 else fib(n-1) + fib(n-2)<!--2--><br />println(fib(30))<br /></pre>Neat huh?<br /><br />And then I timed this repeatedly and all results were about the same:<br /><pre>andraz@andraz-desktop:/tmp/temp$ time scrat fib.scrat <br />1346269.0<br /><br />real 0m3.254s<br />user 0m3.652s<br />sys 0m0.096s<br /></pre>Of course there is some startup overhead that must be taken into account so I ran an empty file<br /><pre>andraz@andraz-desktop:/tmp/temp$ time scrat empty <br /><br />real 0m0.420s<br />user 0m0.448s<br />sys 0m0.032s<br /></pre>To obtain total <a href="http://en.wikipedia.org/wiki/Time_complexity" rel="wikipedia" target="_blank" title="Time complexity">running time</a> of 3254 - 420 = 2830ms<br /><h3>Javascript</h3><div>Then I translated my source into js. Below is the untouched(apart from whitespace) result <br /><pre>function fib(n){<br />    return (function(){<br />        if(n<2.0){<br />           return 1.0;<br />        } else {<br />           return (fib((n)-(1.0)))+(fib((n)-(2.0)));<br />        }<br />    }());<br />}<br /></pre>In scrat ifs are expressions too, so the if is wrapped in an <a href="http://en.wikipedia.org/wiki/Anonymous_function" rel="wikipedia" target="_blank" title="Anonymous function">anonymous function</a>. In spite of additional invocations, running time decreased dramaticaly: 128ms.<br /><br />Real reason for this test was my wory of if overhead so I did a by-hand implementation</div><pre>function fib(n){<br />    if(n<2){<br />        return 1;<br />    } else {<br />        return fib(n-1)+fib(n-2);<br />    }<br />}<br /></pre>Running time: 35ms.<br />Auch! Wrapping the if statement into an if expression multiplies running time by almost 4!! But it's still 22 times faster than my interpreter. (My code sucks I guess)<br /><h3>C</h3><div>At this point you should be wondering what does this has to do with C. Not much. I tried to do an implementation in C just for kicks. To see how much overhead my by-head function still has. I was assuming C program will go in something like 10ms.</div><div>My best attempt(in the same style: recursion, if expression)</div><pre>#include <stdio.h> <stdio .h=".h"><br /><br />int fib(int n){<br /> return (n<2)?1:fib(n-1)+fib(n-2);<br />}<br /><br />int main(){<br /> printf("%d", fib(39));<br /> return 0;<br />}<br /></stdio></pre>Startup time is neglectible here, since it doesn't load an interpreter or a framework, and I wouldn't even know hoe to measure it. So here's the full running time..ready?<br /><b>634 fricking miliseconds!</b><br />That's only 4 times faster than my interpreted code. And 18 times slower than javascript. I'm not sure how is this even possible. It's probably just my bad implementation. But rules were: keep the style.<br />So I hereby declare: js is faster than C. (in this microbenchmark)<br /><h2>UPDATE:</h2><div>I did something terribly wrong. Look at the C code closely. Its fib(39) where in scrat and js I called fib(30). I just compared apples and oranges. </div><div>Fixing the C code I got average 20ms. A bit faster than node. So it turns out javascript isn't faster than light(c) but it's pretty damn close. </div><div>I guess this whole post is now wrong, but it was fun to do nonetheless. </div><div style="margin-top: 20px; overflow: hidden;">