<!doctype html><html><head><title>Implementing apply on tuples in Scala</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.3bdd3e0bba961aa48fdce1402e6f01783c435b4dfb0025c8d0022ddaea0f3d19.css media=screen><script src=/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>My Programming Escapades</div><div class=nav-subtitle>Andraz Bajt</div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>My Programming Escapades</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>My Programming Escapades</div><div class=single-column-header-subtitle>Andraz Bajt</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Implementing apply on tuples in Scala<div class=post-meta><time itemprop=datePublished>2017-09-01</time></div></div></div><div class=post-body-wrapper><div class=post-body><p>One of the first things you learn as a newcomer to Scala is the difference
between a list and a tuple: a list must be homogeneous but a tuple can be
heterogeneous. That is all elements of a list must have the same types but a
tuple can contain things of different types.</p><p>A direct consequence of this is that a list can define a by-index accessor and
a tuple cannot. You can use <code>list(3)</code> but you can't do <code>tuple(3)</code> - you need to
do <code>tuple._4</code> (and there is that pesky off-by-one).</p><p>So let's use the awesome powers of Scala to negate this and implement <code>apply</code>
method on tuples.</p><h2 id=first-steps>First steps</h2><p>Let's start with with baby steps and not tackle full blown <code>apply</code> with integer
index but instead do an approximation with special access constants. Something
like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> t1 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>123</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>val</span> t2 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1234</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foobar&#34;</span><span style=color:#f92672>)</span>

println<span style=color:#f92672>(</span>t1<span style=color:#f92672>(</span>_2<span style=color:#f92672>)</span><span style=color:#f92672>)</span> <span style=color:#75715e>// prints 123
</span><span style=color:#75715e></span>println<span style=color:#f92672>(</span>t2<span style=color:#f92672>(</span>_1<span style=color:#f92672>)</span><span style=color:#f92672>)</span> <span style=color:#75715e>// prints false
</span><span style=color:#75715e></span>println<span style=color:#f92672>(</span>t2<span style=color:#f92672>(</span>_3<span style=color:#f92672>)</span><span style=color:#f92672>)</span> <span style=color:#75715e>// prints &#34;foobar&#34;
</span></code></pre></div><p>It's not a big step from regular tuple accessors but it's a big move since it
introduces a single polymorphic <code>apply</code>.</p><p>To pull this off we'll type classes in conjunction with singleton types. The
<code>apply</code> will take in one of the singletons and use implicit resolution to pull
in the function that does the proper projection. The important part is that the
implicit resolution also needs to compute the output type of the <code>apply</code>
method.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#75715e>// this integer references can be avoided when/if SIP-23 is implemented
</span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> _1 <span style=color:#66d9ef>=</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Integer</span>
<span style=color:#66d9ef>val</span> _2 <span style=color:#66d9ef>=</span> <span style=color:#ae81ff>2</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Integer</span>
<span style=color:#66d9ef>val</span> _3 <span style=color:#66d9ef>=</span> <span style=color:#ae81ff>3</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Integer</span>
<span style=color:#75715e>// ... up to 22
</span></code></pre></div><p>The type-class needs to correlate the tuple type (<code>T</code>), the output type (<code>A</code>)
and the index (<code>N</code>). The instances just implement the obvious connection
between indexes and tuple accessors.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>N</span> <span style=color:#66d9ef>&lt;:</span> <span style=color:#66d9ef>Integer</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span>
<span style=color:#f92672>}</span>
<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>TupleGet</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple2get1<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>_</span><span style=color:#960050;background-color:#1e0010>1</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_1
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple2get2<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>_</span><span style=color:#960050;background-color:#1e0010>2</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_2
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3get1<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>_</span><span style=color:#960050;background-color:#1e0010>1</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_1
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3get2<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>_</span><span style=color:#960050;background-color:#1e0010>2</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_2
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3get3<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>C</span>, <span style=color:#66d9ef>_</span><span style=color:#960050;background-color:#1e0010>3</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>C</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_3
  <span style=color:#f92672>}</span>
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>If you haven't seen types like <code>_1.type</code> before: this is precisely the type of
the value <code>_1</code>. Only its exact copies can inhabit it at any time.</p><p>Now we can write the extension <code>apply</code> method that uses this mechanism.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TupleAccessor</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>tuple<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>i<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Integer</span><span style=color:#f92672>)</span><span style=color:#f92672>(</span><span style=color:#66d9ef>implicit</span> getter<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>TupleGet</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>i</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>type</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span>
    getter<span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>tuple<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>And it will work. But you need to use <code>_1</code> instead of regular <code>1</code> to give the
implicit resolution mechanism sufficient clues. Not pretty enough.</p><h2 id=enter-nats>Enter Nats</h2><p>To integrate deeper with the language we need to lift the integers into the
type level somehow.</p><p>Since I don't feel like writing 22 instances let's start off with unary
encoding.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>TNat</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TZero</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>TNat</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>A</span> <span style=color:#66d9ef>&lt;:</span> <span style=color:#66d9ef>TNat</span><span style=color:#f92672>]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>TNat</span>
</code></pre></div><p>And a corresponding value level representation that also keeps the type around
with an implicit conversion from integers so this is all auto-magical.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>N</span> <span style=color:#66d9ef>&lt;:</span> <span style=color:#66d9ef>TNat</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Zero</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>N</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>TZero</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Succ</span><span style=color:#f92672>(</span>prev<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Nat</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>N</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>prev</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>N</span><span style=color:#f92672>]</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> fromInt<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Nat</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    assert<span style=color:#f92672>(</span>n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      <span style=color:#a6e22e>Zero</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
      <span style=color:#a6e22e>Succ</span><span style=color:#f92672>(</span>fromInt<span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>The trick here is the type member that is defined to match the number itself.
This way the type checker gets access to the &ldquo;value. Now we just need to
rewrite the instances to use this.</p><p>Except it doesn't work. This mechanism will generate the <code>Nats</code> but it's too
weak - <code>N</code> will just be <code>n.N</code> and this is not enough information to power
implicit resolution. If only there was a way to fully generate the types at
compile time&mldr;</p><h2 id=macros-to-the-rescue>Macros to the rescue</h2><p>We can keep the <code>Nat</code> type and the implicit conversion into it but implement it
as a macro that just generates <code>TNat</code>s directly (without recursion). This will
give strong enough types to power implicit resolution.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>N</span> <span style=color:#66d9ef>&lt;:</span> <span style=color:#66d9ef>TNat</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Nat</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> fromIntImpl<span style=color:#f92672>(</span>c<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Context</span><span style=color:#f92672>)</span><span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>c.Expr</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>c.Expr</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Nat</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>import</span> c.universe._
    <span style=color:#66d9ef>val</span> value <span style=color:#66d9ef>=</span> c<span style=color:#f92672>.</span>eval<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>val</span> type_ <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>1</span> to value<span style=color:#f92672>)</span><span style=color:#f92672>.</span>foldLeft<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;TZero&#34;</span><span style=color:#f92672>)</span><span style=color:#f92672>(</span> <span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#e6db74>s&#34;</span><span style=color:#e6db74>TSucc[</span><span style=color:#e6db74>$t</span><span style=color:#e6db74>]</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
    c<span style=color:#f92672>.</span><span style=color:#a6e22e>Expr</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Nat</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>c<span style=color:#f92672>.</span>parse<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;</span><span style=color:#e6db74>new Nat { type N = </span><span style=color:#e6db74>$type_</span><span style=color:#e6db74> }</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> fromInt<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Nat</span> <span style=color:#f92672>=</span> macro fromIntImpl
<span style=color:#f92672>}</span>
</code></pre></div><p>Now we can rewrite the instances.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>N</span> <span style=color:#66d9ef>&lt;:</span> <span style=color:#66d9ef>TNat</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span>
<span style=color:#f92672>}</span>
<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>At</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple2_at0<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>TZero</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_1
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple2_at1<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>TZero</span><span style=color:#f92672>]</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_2
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3_at0<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>TZero</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_1
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3_at1<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>TZero</span><span style=color:#f92672>]</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_2
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> tuple3_at2<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>At</span><span style=color:#f92672>[</span><span style=color:#f92672>(</span><span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>C</span><span style=color:#f92672>)</span>, <span style=color:#66d9ef>C</span>, <span style=color:#66d9ef>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>TSucc</span><span style=color:#f92672>[</span><span style=color:#66d9ef>TZero</span><span style=color:#f92672>]</span><span style=color:#f92672>]</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>B</span><span style=color:#f92672>,</span> C<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>C</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span>_3
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>And it works!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TupleGet</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>t<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Nat</span><span style=color:#f92672>)</span><span style=color:#f92672>(</span><span style=color:#66d9ef>implicit</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>At</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span>, <span style=color:#66d9ef>A</span>, <span style=color:#66d9ef>n</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>N</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> at<span style=color:#f92672>(</span>t<span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>def</span> main<span style=color:#f92672>(</span>args<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Array</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>val</span> t1 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>123</span><span style=color:#f92672>)</span>
      <span style=color:#66d9ef>val</span> t2 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1234</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foobar&#34;</span><span style=color:#f92672>)</span>

      println<span style=color:#f92672>(</span>t1<span style=color:#f92672>(</span><span style=color:#ae81ff>0</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
      println<span style=color:#f92672>(</span>t2<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
      println<span style=color:#f92672>(</span>t2<span style=color:#f92672>(</span><span style=color:#ae81ff>2</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=simplifying>Simplifying</h2><p>Since we already have a macro sitting in there why not have it do all the heavy
lifting? We can cut bulk of the code and remove a lot of the complexity of the
implicits if we just use a macro that transforms <code>a.apply(n)</code> into <code>a._${n + 1}</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> tupleApplyImpl<span style=color:#f92672>(</span>c<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Context</span><span style=color:#f92672>)</span><span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>c</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>Tree</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>c</span><span style=color:#66d9ef>.</span><span style=color:#66d9ef>Tree</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>import</span> c.universe._
  <span style=color:#66d9ef>val</span> value <span style=color:#66d9ef>=</span> c<span style=color:#f92672>.</span>eval<span style=color:#f92672>(</span>c<span style=color:#f92672>.</span><span style=color:#a6e22e>Expr</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>n<span style=color:#f92672>)</span><span style=color:#f92672>)</span>
  <span style=color:#66d9ef>val</span> q<span style=color:#e6db74>&#34;$_($tuple)&#34;</span> <span style=color:#66d9ef>=</span> c<span style=color:#f92672>.</span>prefix<span style=color:#f92672>.</span>tree
  c<span style=color:#f92672>.</span>parse<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;</span><span style=color:#e6db74>${</span>tuple<span style=color:#f92672>.</span>toString<span style=color:#e6db74>}</span><span style=color:#e6db74>._</span><span style=color:#e6db74>${</span>value <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TupleOps</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>tuple<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span> <span style=color:#f92672>=</span> macro tupleApplyImpl
<span style=color:#f92672>}</span>
</code></pre></div><p>This works but I think it's not the best idea. See, macros don't compose. You
cannot really use this from another function, you always need to statically
know the index. As where with the previous implementation you are good to go as
long as you have a good <code>Nat</code> and the <code>At</code> instance. Which you can pass in
programmatically. And you just push the implicit conversion to <code>Nat</code> a layer
out. This way you can re-use the indexing mechanism for other operations and
you just have a single macro sitting in the background powering things instead
of having a bunch of one-offs.</p><p>In fact this is exactly what
<a href=https://github.com/milessabin/shapeless/wiki>shapeless</a> already does! It uses
very similar ideas and pushes them much further. But most importantly, it
already includes our <code>apply</code> so if you actually want to do this just import
shapeless.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>import</span> shapeless.syntax.std.tuple._

<span style=color:#66d9ef>val</span> t1 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>123</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>val</span> t2 <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1234</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foobar&#34;</span><span style=color:#f92672>)</span>

println<span style=color:#f92672>(</span>t1<span style=color:#f92672>.</span>apply<span style=color:#f92672>(</span><span style=color:#ae81ff>0</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
println<span style=color:#f92672>(</span>t2<span style=color:#f92672>.</span>apply<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
println<span style=color:#f92672>(</span>t2<span style=color:#f92672>.</span>apply<span style=color:#f92672>(</span><span style=color:#ae81ff>2</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
</code></pre></div><hr width=100%><p style=color:#777>Last modified on 2017-09-01</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2018-01-24-nixos-install-pains/>Next<br>NixOS install & labor pains</a>
<a class=older-posts href=/posts/2017-08-30-dockerless-services/>Previous<br>Dockerless Services (with Nix)</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div><script src=//js/journal.js></script></body></html>