<!doctype html><html><head><title>Lazy unary numbers</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.01c37d732f853bf90329007dc6f0a25c67722dd47b7168f8907facb93414bd91.css media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons"></head><body><div id=app><div ref=sideContainer class=side-container><div class="a-block nav-head false"><div class=nav-title>Andraž Bajt's blog</div><div class=nav-subtitle></div><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div class=nav-link-list><a class="a-block nav-link-item" href=/about>About Me</a>
<a class="a-block nav-link-item" href=/>Archive</a></div><div class=nav-footer>&copy;
2021
Andraz Bajt</div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item" href=/about>About Me</a>
<a class="a-block drawer-menu-item" href=/>Archive</a></div></div></div><div class=single-column-header-container ref=pageHead><a href=/><div class=single-column-header-title>Andraž Bajt's blog</div></a><a href=https://github.com/edofic><img src=/icons/github.svg width=20></a>
<a href=https://www.linkedin.com/in/edofic><img src=/icons/linkedin.svg width=20></a>
<a href=https://twitter.com/edofic><img src=/icons/twitter.svg width=20></a>
<a href=/index.xml><img src=/icons/rss.svg width=20></a>
<a href=mailto:edofic@edofic.com><img src=/icons/email.svg width=20></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Lazy unary numbers<div class=post-meta><time itemprop=datePublished>2015-05-03</time></div></div></div><div class=post-body-wrapper><div class=post-body><p>We are used to encoding numbers on computers in binary. Binary is the &ldquo;simplest&rdquo; base that yields logarithmic length though it <a href=http://web.williams.edu/Mathematics/sjmiller/public_html/105Sp10/addcomments/Hayes_ThirdBase.htm>may not be optimal</a>. But can we do simpler? How about unary?</p><p>Unary is often used with Turing machines where we don&rsquo;t care for efficiency and I will assume this same stance. Let&rsquo;s forget about efficiency and explore what can unary numbers do that binary can&rsquo;t. Specifically lazy unary numbers as otherwise the systems are equivalent. I&rsquo;ll be using Haskell as it is lazy by default and thus a good fit.</p><p>Let&rsquo;s start off with a simple definition.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Nat</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>Nat</span> <span style=color:#66d9ef>deriving</span> <span style=color:#66d9ef>Eq</span>
</code></pre></div><p>This are natural numbers as usually defined in mathematics. An example value (3) in this encoding would be <code>Succ $ Succ $ Succ Zero</code>. For the sake of simplicity I will from now on assume that we do not use bottom values that correspond to errors.</p><h2 id=infinity>Infinity</h2><p>The first interesting property of this representation is a simple encoding of infinity in finite space.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>nInf</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Nat</span>
<span style=color:#a6e22e>nInf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> nInf
</code></pre></div><p>This ties the knot and only constructs one <code>Succ</code> that points to itself. The interesting (and useless) bit is that we cannot observe this in a given value! At least not in pure functions. Given a <code>Nat</code> we cannot possibly know if it is infinite or just very large.</p><h2 id=equality-and-ordering>Equality and ordering</h2><p>I just derived <code>Eq</code> before not giving it much thought. But notice now that comparison between two <code>Nat</code>s may not return if both are infinite. However if one is finite we can detect that the two are not equal. All is not lost. We can even do more and define ordering</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Ord</span> <span style=color:#66d9ef>Nat</span> <span style=color:#66d9ef>where</span>
  <span style=color:#66d9ef>Zero</span> `compare` <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>EQ</span>
  <span style=color:#66d9ef>Zero</span> `compare` <span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>LT</span>
  <span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>_</span> `compare` <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>GT</span>
  <span style=color:#66d9ef>Succ</span> n `compare` <span style=color:#66d9ef>Succ</span> m <span style=color:#f92672>=</span> n `compare` m
</code></pre></div><p>This does the obvious thing: it &ldquo;zips&rdquo; the two numbers together and finds a differing spot if there is any. Again it will loop forever if both numbers are infinite.</p><h2 id=more-instances>More instances</h2><p>This type is also enumerable which can be implemented by an isomorphisim with integer
via an <code>Enum</code> instance</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Enum</span> <span style=color:#66d9ef>Nat</span> <span style=color:#66d9ef>where</span>
  toEnum <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span>
  toEnum n <span style=color:#f92672>|</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> <span style=color:#f92672>$</span> toEnum <span style=color:#f92672>$</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>

  fromEnum <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  fromEnum (<span style=color:#66d9ef>Succ</span> n) <span style=color:#f92672>=</span> fromEnum n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</code></pre></div><p>Given this we can now show <code>Nat</code> as a decimal number</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Show</span> <span style=color:#66d9ef>Nat</span> <span style=color:#66d9ef>where</span>
  show n <span style=color:#f92672>=</span> show <span style=color:#f92672>$</span> fromEnum n
</code></pre></div><p>And I saved the best for last: full <code>Num</code> instance</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Num</span> <span style=color:#66d9ef>Nat</span> <span style=color:#66d9ef>where</span>
  <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>+</span> m <span style=color:#f92672>=</span> m
  <span style=color:#66d9ef>Succ</span> n <span style=color:#f92672>+</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> <span style=color:#f92672>$</span> n <span style=color:#f92672>+</span> m

  n <span style=color:#f92672>*</span> <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span>
  <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>*</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span>
  n <span style=color:#f92672>*</span> <span style=color:#66d9ef>Succ</span> m <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> n <span style=color:#f92672>*</span> m

  <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>-</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span>
  n <span style=color:#f92672>-</span> <span style=color:#66d9ef>Zero</span> <span style=color:#f92672>=</span> n
  <span style=color:#66d9ef>Succ</span> n <span style=color:#f92672>-</span> <span style=color:#66d9ef>Succ</span> m  <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> m

  fromInteger <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zero</span>
  fromInteger n <span style=color:#f92672>|</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>     <span style=color:#f92672>=</span> fromInteger <span style=color:#f92672>$</span> negate n
                <span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> <span style=color:#f92672>$</span> fromInteger <span style=color:#f92672>$</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>

  negate <span style=color:#f92672>=</span> <span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#34;cannot represent negative Nat&#34;</span>
  abs <span style=color:#f92672>=</span> id
  signum <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Succ</span> <span style=color:#66d9ef>Zero</span>
</code></pre></div><p>Let&rsquo;s walk through it. Addition recurses on first argument. Note that the second argument is reused. It will only allocate <code>Succ</code>s matching the first argument.</p><p>Multiplication again recurses on one argument but does addition at each step. Since there is no way to represent negative numbers in this scheme I defined <code>0 - n = 0</code> which is a bit shady but works in most cases. Similarly <code>negate</code> throws an error. Anther consequence is that <code>abs</code> is just identity and <code>signum</code> always returns <code>1</code>.</p><p>But the most useful function is <code>fromInteger</code>. I extended <code>toEnum</code> by handling negative cases. This does not look like much but due to literal polymorphism we can now write decimal literals and they will be automatically converted to <code>Nat</code> where this is the expected type.</p><h2 id=conclusion>Conclusion</h2><p>There are two interesting things. First is encoding infinity. Not much on itself. But the second thing is partial evaluation. By traversing <em>n</em> <code>Succ</code>s we know that the number is greater or equal to <em>n</em>. This means we can compute even with infinite numbers as long as we don&rsquo;t need to look at the exact result.</p><hr width=100%><p style=color:#777>Last modified on 2015-05-03</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2016-02-24-git-repair/>Next<br>Repairing a corrupt Git repo using a clone</a>
<a class=older-posts href=/posts/2015-05-02-tagged-types/>Previous<br>Cheap tagged types in Scala</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>&copy;
2021
Andraz Bajt</div></div></body></html>