---
title: Cool Monday: HList and Shapeless
---

<div><table cellpadding="0" cellspacing="0" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><div><div><a href="http://en.wikipedia.org/wiki/File%3AJava_logo.svg" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="Java (programming language)" border="0" class="zemanta-img-inserted" height="320" src="http://upload.wikimedia.org/wikipedia/en/thumb/3/39/Java_logo.svg/300px-Java_logo.svg.png" style="border: none; font-size: 0.8em;" width="174" /></a></div></div></td></tr><tr><td style="text-align: center; width: 300px;">Java (programming language) (Photo credit: <a href="http://en.wikipedia.org/wiki/File%3AJava_logo.svg" target="_blank">Wikipedia</a>)</td></tr></tbody></table>HList as in <a href="http://en.wikipedia.org/wiki/Homogeneity_and_heterogeneity" rel="wikipedia" target="_blank" title="Homogeneity and heterogeneity">heterogenous</a> lists. This means every element is of different type. Yeah sure, just list List<Object> in Java, but that is in no way typesafe. I want compiler to know the type of every element and stop me if I try to do something silly.<br /><h3><a href="http://en.wikipedia.org/wiki/Linked_list" rel="wikipedia" target="_blank" title="Linked list">Linked lists</a> to the rescue</h3><div>So what's a <a href="http://en.wikipedia.org/wiki/Linked_list" rel="wikipedia" target="_blank" title="Linked list">linked list</a> anyway? A sequence of nodes with pointers to next. And a nice implementation(still talking <a href="http://www.oracle.com/technetwork/java/" rel="homepage" target="_blank" title="Java (programming language)">Java</a> here) would be generic to allow <a href="http://en.wikipedia.org/wiki/Type_safety" rel="wikipedia" target="_blank" title="Type safety">type-safety</a> forÂ homogeneous lists. It turns out generic are solution for HLists too. Just introduce additional <a href="http://en.wikipedia.org/wiki/TypeParameter" rel="wikipedia" target="_blank" title="TypeParameter">type parameter</a>. Apocalisp has a <a href="http://apocalisp.wordpress.com/2008/10/23/heterogeneous-lists-and-the-limits-of-the-java-type-system/" target="_blank">great post</a> on implementing them in Java. Here's just a <a href="http://en.wikipedia.org/wiki/Factory_method_pattern" rel="wikipedia" target="_blank" title="Factory method pattern">factory method</a> to see the gist</div><pre>public static <E, L extends HList<L>> HCons<E, L><e extends="" hlist="hlist" l=""> HC<e l=""><a href="http://en.wikipedia.org/wiki/Cons" rel="wikipedia" target="_blank" title="Cons">ons</a>(final E e, final L l) {<br />   return new HCons<E,L><e l="">(e, l);<br />}<br /></e></e></e></pre><div>Problem comes with instantiation.</div><pre><string hcons="hcons" hnil="hnil" nteger="nteger" oolean="oolean">final HCons<double a="" hcons="hcons" href="http://en.wikipedia.org/wiki/Integer_%28computer_science%29" rel="wikipedia" string="string" target="_blank" title="Integer (computer science)">Integer[], HNil>>> b =<br />      cons(4.0, cons("Bar", cons(new Integer[]{1, 2}, nil())));<br /></double></string></pre>Java requires A LOT of <a href="http://en.wikipedia.org/wiki/Type_signature" rel="wikipedia" target="_blank" title="Type signature">type annotation</a>. It works but it's just painful and it doesn't pay off.   <br /><h3><a href="http://en.wikipedia.org/wiki/Type_inference" rel="wikipedia" target="_blank" title="Type inference">Type inference</a> to the rescue</h3><div>Type inference gets rid of this problem entirely. Let's implement whole working HList in scala.</div><pre><a href="http://en.wikipedia.org/wiki/Abstract_type" rel="wikipedia" target="_blank" title="Abstract type">abstract class</a> HList[H,T<:HList[_,_]] {<br />  def head: H<br />  def tail: T<br />  def ::[A](a: A) = Hcons(a, this)<br />}<br /><br />object HNil extends HList[Nothing, Nothing]{<br />  def head = throw new IllegalAccessException("head of empty hlist")<br />  def tail = throw new IllegalAccessException("tail of empty hlist")<br />}<br /><br />case class Hcons[H,T<:HList[_,_]](private val hd: H, private val tl: T) extends HList[H, T]{<br />  def head = hd<br />  def tail = tl<br />}<br /></pre>So this list can be instantiated like this <br /><pre>scala> val myHList = 1 :: "hi" :: 2.0 :: HNil<br />myHList: Hcons[Int,HList[java.lang.String,HList[Double,HList[Nothing,Nothing]]]] = Hcons(1,Hcons(hi,Hcons(2.0,HNil$@dbb62c)))<br /></pre><div><br /></div>And it just works. Scala compiler does all the heavy lifting with type annotations. This implementation bare bones and doesn't provide any useful methods(even random access!). Check out Miles Sabin's <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless project</a> for a useful implementation and much more. I provides indexing, map, fold, concatenation, type-safe casts, conversions to tuples(and abstracting over arities!) and back. And even conversions with case classes. Just click the link above and read the readme. It's awesome.<br /><div style="margin-top: 20px; overflow: hidden;">