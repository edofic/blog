<!DOCTYPE html>
<html><head>
<title>Linear time sorting</title>

<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">




<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>



<link rel="stylesheet" href="/scss/journal.min.9d1b3d6c4f3ff1773fff9bdca1bc24452f33129e12f67f2ab14f2ddaf1603468.css" media="screen">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>

</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    <div class="a-block nav-head false">
        <div class="nav-title">
            My Programming Escapades
        </div>
        <div class="nav-subtitle">
            
                Andraz Bajt
            
        </div>
            
                <a href="https://github.com/edofic"><img src="/icons/github.svg" width="20"/></a>
            
            
                <a href="https://www.linkedin.com/in/edofic"><img src="/icons/linkedin.svg" width="20"/></a>
            
            
                <a href="https://twitter.com/edofic"><img src="/icons/twitter.svg" width="20"/></a>
            
            
            
                <a href="mailto:edofic@edofic.com"><img src="/icons/email.svg" width="20"/></a>
            
    </div>


    <div class="nav-link-list">
        
        
            
            
            <a class="a-block nav-link-item" href="/about">
                About Me
            </a>
        
            
            
            <a class="a-block nav-link-item" href="/">
                Archive
            </a>
        
    </div>

    <div class="nav-footer">
        &copy;
    2020
	
	Andraz Bajt
	

    </div>

</div>
<div ref="extraContainer" class="extra-container">
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
    </div>
</div><div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
        
        
            
                
                
                <a class="a-block drawer-menu-item" href="/about">
                    About Me
                </a>
        
            
                
                
                    
                
                <a class="a-block drawer-menu-item" href="/">
                    Archive
                </a>
        
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            My Programming Escapades
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
        <a href="/">
            <div class="single-column-header-title">My Programming Escapades</div>
            
            <div class="single-column-header-subtitle">Andraz Bajt</div>
            
        </a>

        
            <a href="https://github.com/edofic"><img src="/icons/github.svg" width="20"/></a>
        
        
            <a href="https://www.linkedin.com/in/edofic"><img src="/icons/linkedin.svg" width="20"/></a>
        
        
            <a href="https://twitter.com/edofic"><img src="/icons/twitter.svg" width="20"/></a>
        
        
        
            <a href="mailto:edofic@edofic.com"><img src="/icons/email.svg" width="20"/></a>
        

</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                 style="background-image: url('/')">
                <div class="post-title">
                    Linear time sorting
                    <div class="post-meta">
                        
                            <time itemprop="datePublished">
                                2018-05-25
                            </time>
                        

                        

                        
                    </div>
                </div>
            </div>

            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>Did you know that you can sort data in time linear with respect to the lenght
of said data?  Some people dismiss linear time sorts because they've learned
that <code>n log n</code> is the bottom bound for sorting an arbitrary input.</p>
<h1 id="but-n-log-n-is-optimal">But <em>n log n</em> is optimal!?</h1>
<p>Let's even sketch out a proof. Any function that sorts an array of elements
will in fact figure out a permutation of elements into a sorted order. Even if
your algorithm does not work in terms of permutations it can be viewed as a
black box that computes a permutation.</p>
<p>There are <code>n!</code> permutations of an array of length <code>n</code>. Each time you compare
two elements there are three possible possible results (less, equal, greater).
You can now imagine a decision tree that has a comparison at each inner node
and a permutation at each leaf.  An optimal tree will be balanced with a
branching factor of 3. Because we know how many leaves we have (<code>n!</code>) we can
compute the depth of the tree. Using Stirling's approximation for factorial
immediately yields the result <code>n log n</code>. This means you have to do at least <code>n log n</code> comparisons to figure out the permutation.</p>
<p>But this is a theorem about <strong>comparison</strong> sorts. You cannot do less than <code>n log n</code> <em>comparisons</em> if all you have is pair-wise comparison. Assuming you can
do comparisons in <code>O(1)</code> this makes your sort <code>O(n log n)</code>. But beware: if your
comparison is not constant-time this is not true any more. If you are comparing
arbitrary precision integers or strings your sort will be <code>O(k n log n)</code> where
<code>k</code> is the length of a single element.</p>
<p>This still leaves place for improvement if you have more structure on your
data. I'm going to talk about the algorithms that have access to the underlying
binary representation of data. Sorting will mean sorting the bit-strings that
represent the data. This is enough for most sorts since you can usually build
up a surrogate key that conforms to this.</p>
<h1 id="a-naive-approach">A naive approach</h1>
<p>Let <code>A</code> be an input array of 16 bit integers. We allocate another array of size
<code>2 ^ 16</code> - 64k. Then we loop over the input</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">tmp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span><span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>)
<span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> A:
  tmp[a] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>This is enough to spit out the sorted array</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">var sorted <span style="color:#f92672">=</span> [];
<span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(A):
  <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(c):
    sorted<span style="color:#f92672">.</span>append(i)
</code></pre></div><p>And we didn't use comparisons! I will even argue this is linear with respect to
the length of the input array. We allocated an array of constant size. This is
<code>O(1)</code>. Then we did one operation per input element. And another when
outputting it. It's a hand-wavy argument but it's only for illustration.  A
slightly less naive version of this is known as counting sort and actually
performs really well on some types of input.</p>
<h1 id="a-generalization">A generalization</h1>
<p>What if we want to use different size of integers? If we just used this
algorithm for 64 bit integers we would run out of space before even starting.</p>
<p>We can tackle this problem by looking at a constant number of bits of each
element at a time. The simplest is just a single bit, but a byte works out
quite well in practice. So now we sort our array by the least significant byte.
We now cannot use the naive counting because index does not tell us anything
about the remaining bytes. We have to replace counters by buckets that hold
elements.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_byte</span>(a, i):
  <span style="color:#66d9ef">return</span> (a <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">*</span> i)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">one_pass</span>(ar, i):
  buckets <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">256</span>)]
  <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> ar:
    buckets[get_byte(a, i)]<span style="color:#f92672">.</span>append(a)
  <span style="color:#66d9ef">return</span> sum(buckets, [])
</code></pre></div><p>And the sorted result is just the concatenation of the buckets. The good thing
about this is that it's a stable sort. It will preserve the order of elements
that it considers equal (at one byte that is). So we can repeat this with other
bytes (going from right to left) and we will end up with a sorted array. This
was not very intuitive to me but if you work through an example by hand you
quickly figure it out.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sort</span>(ar):
  num_bytes <span style="color:#f92672">=</span> int(math<span style="color:#f92672">.</span>ceil(math<span style="color:#f92672">.</span>log(max(ar), <span style="color:#ae81ff">2</span>)))
  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(num_bytes):
    ar <span style="color:#f92672">=</span> one_pass(ar, i)
  <span style="color:#66d9ef">return</span> ar
</code></pre></div><p>We can compact it all into one simple function</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sort</span>(ar):
  num_bytes <span style="color:#f92672">=</span> int(math<span style="color:#f92672">.</span>ceil(math<span style="color:#f92672">.</span>log(max(ar), <span style="color:#ae81ff">2</span>)))
  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(num_bytes):
    buckets <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">256</span>)]
    <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> ar:
      buckets[(a <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">*</span> i)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>]<span style="color:#f92672">.</span>append(a)
    ar <span style="color:#f92672">=</span> sum(buckets, [])
  <span style="color:#66d9ef">return</span> ar
</code></pre></div><p>This is known as Least Significant Byte (LSB) Radix Sort. Let's take a quick
look at it's complexity. It does a constant amount of work (one append) per
each byte of input. So it's linear with respect to number of input bytes. For
fixed precision numbers this means it's even linear with respect to number of
input elements. Great! This is very simple. Well&hellip; not so quick. There's many
variations and tradeoffs to be made. One I quote like is the <a href="https://en.wikipedia.org/wiki/American_flag_sort">American Flag
Sort</a> - which is an in-place
top down variation. This entails that you can use it to efficiently sort things
other than integers -&gt; if you can discriminate them into equality buckets.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I think linear time sorting is under-appreciated and could be used more
problems more efficiently but it isn't easily accessible enough.  I only became
interested in the topic after hearing <a href="https://www.youtube.com/watch?v=cB8DapKQz-I">Edward Kmett's awesome talk on the
topic</a> He also wrote <a href="https://hackage.haskell.org/package/discrimination">an amazing
library for Haskell</a> that
makes linear time sorting and grouping trivial to use when you need it. This is
the only library of the sort that I know of, buy as you've seen above, even
rolling your own is not that hard. So if that extra <em>log n</em> is bothering you,
remember the radix.</p>

                    <HR width="100%">
                    
                    <p style="color:#777;">Last modified on 2018-05-25</p>
                    
                </div>

            </div>


            <nav class="post-pagination">

                
                <a class="newer-posts" href="/posts/2020-01-15-hugo/">
                    Next<br>Moving to Hugo
                </a>
                

                
                <a class="older-posts" href="/posts/2018-01-25-jira-gsheet/">
                    Previous<br>Integrating Jira into Google Sheets
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                



            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">&copy;
    2020
	
	Andraz Bajt
	
</div>
    	</div>
    <script src="//js/journal.js"></script>
    </body>
</html>
