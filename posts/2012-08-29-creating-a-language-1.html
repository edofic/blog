---
title: Making a programming language: Part 1 - how to start
---

<h3>Table of contents</h3><div><ul><li>Part 1 - how to start (this article)</li><li><a href="/posts/2012-08-30-creating-a-language-2.html">Part 2 - something that kinda works</a></li><li><a href="/posts/2012-08-31-creating-a-language3.html" target="_blank">Part 3 - adding features</a></li><li><a href="/posts/2012-09-01-creating-a-language4.html" target="_blank">Part 4 - Hello World</a></li><li><a href="/posts/2012-09-02-creating-a-language-5.html" target="_blank">Part 5 - variables and decisions</a></li><li><a href="/posts/2012-09-25-creating-a-language-6.html" target="_blank">Part 6 - user defined functions</a></li><li><a href="/posts/2012-09-27-creating-a-language-7a.html" target="_blank">Part 7a - constructors and objects</a></li><li><a href="/posts/2012-10-08-creating-a-language-7b.html" target="_blank">Part 7b - using objects</a></li><li><a href="/posts/2012-09-29-creating-a-language-8.html" target="_blank">Part 8 - going faster</a></li></ul></div><h4><a href="https://github.com/edofic/scrat-lang/tree/blogpost1and2">Source version for this post</a></h4>Lately I gained some interest in <a href="http://en.wikipedia.org/wiki/Programming_language" rel="wikipedia" target="_blank" title="Programming language">programming languages</a> and <a href="http://en.wikipedia.org/wiki/Compiler" rel="wikipedia" target="_blank" title="Compiler">compilers</a>. Those seem like quite some daunting monsters - just consider the amount of different features and more importantly, the vast infinity of possible programs.So where to start? I have a course about compilers at my college, but I have to wait another year to enroll into that. So welcome <a href="https://www.coursera.org/course/compilers" target="_blank">Coursera</a>. It's currently available only in self-study but that's enough for me. I should mention the <a href="http://www.amazon.com/Compilers-Principles-Techniques-Alfred-Aho/dp/0201100886%3FSubscriptionId%3D0G81C5DAZ03ZR9WH9X82%26tag%3Dzem-20%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0201100886" rel="amazon" target="_blank" title="Compilers: Principles, Techniques, and Tools">Dragon Book</a>, but I didn't read that(yet) so I can't comment.Compiler is basicaly lexer -> parser -> optimiser -> <a href="http://en.wikipedia.org/wiki/Code_generation_%28compiler%29" rel="wikipedia" target="_blank" title="Code generation (compiler)">code generator</a>.<h3></h3><h3>The regex approach</h3><div>I made it through introduction and lesson on <a href="http://en.wikipedia.org/wiki/Lexical_analysis" rel="wikipedia" target="_blank" title="Lexical analysis">lexical analysis</a> and recognized <a href="http://en.wikipedia.org/wiki/Finite-state_machine" rel="wikipedia" target="_blank" title="Finite-state machine">finite automata</a> as something from college(thank your professor!) and finnaly understood the connection from them to regex in java and the like(professor mentioned <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="wikipedia" target="_blank" title="Regular expression">regular expressions</a> but no-one figured out what was the connection). </div><div>Feeling empowered by the newly obtained knowledge I set out to make a lexer for my language.  I had no clear specification in mind since this is supposed to be a fun and creative project...I intended to just invent as I go.</div><div>My lexer was something like that(won't post the real code since I'm embarrassed)<ul><li>create a bunch of java regex objects that all match to the start of the string</li><li>take the string and try to match it against all regexes</li><li>return an identifier object corresponding to the match</li><li>remove matched part of the string</li><li>loop</li></ul>Yeah, pretty horrible.I kinda abandoned this idea.<h3>The <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser" rel="wikipedia" target="_blank" title="Recursive descent parser">recursive descent parser</a> approach</h3></div><div>By now I was into <a href="http://en.wikipedia.org/wiki/Functional_programming" rel="wikipedia" target="_blank" title="Functional programming">functional programming</a> and <a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">scala language</a>.  I also watched lesson on recursive descent on coursera. The code was fugly, bunch of c++ with <a href="http://en.wikipedia.org/wiki/Pointer_%28computing%29" rel="wikipedia" target="_blank" title="Pointer (computing)">pointer arithmetic</a> and side effects. I wan't pretty functions :(</div><div>I considered doing a framework for this in scala or perhaps java but...</div><div><table cellpadding="0" cellspacing="0" style="float: right; text-align: right;"><tbody><tr><td style="text-align: center;"><div><div><div><div><div><div><div><a href="http://en.wikipedia.org/wiki/File%3AScala_logo.png" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="Scala (programming language)" border="0" class="zemanta-img-inserted" height="56" src="http://upload.wikimedia.org/wikipedia/en/thumb/8/85/Scala_logo.png/300px-Scala_logo.png" style="border: none; font-size: 0.8em;" width="200" /></a></div></div></div></div></div></div></div></td></tr><tr><td style="text-align: center; width: 300px;">Scala (programming language) (Photo credit: <a href="http://en.wikipedia.org/wiki/File%3AScala_logo.png" target="_blank">Wikipedia</a>)</td></tr></tbody></table>Enter scala's <a href="http://en.wikipedia.org/wiki/Parser_combinator" rel="wikipedia" target="_blank" title="Parser combinator">parser combinators</a>. I suggest reading <a href="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators" target="_blank">this</a> if you arent familiar. One of the reasons scala is awesome. You get parser "generation" baked into the standard library. Granted, it's a bit slow, but who cares - this is a project for fun not for general usage. On the PLUS side you get productions in the laguage itself and parsing is almost like magic.</div><div>And in scaladoc you even get a nice <a href="http://www.scala-lang.org/api/current/index.html#scala.util.parsing.combinator.RegexParsers" target="_blank">code snippet</a>. What more can a geek ask for.</div><div></div><div>Well....an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="wikipedia" target="_blank" title="Abstract syntax tree">AST</a> would be nice. Fortunately scala also provides action combinators that allow to <a href="http://en.wikipedia.org/wiki/Pattern_matching" rel="wikipedia" target="_blank" title="Pattern matching">pattern match</a> the <a href="http://en.wikipedia.org/wiki/Parsing" rel="wikipedia" target="_blank" title="Parsing">parsers</a> themself and map them into an AST. And it even isn't that complicated. </div><div></div><div>I recreated the grammar from the scaladoc example and added the action combinators. The code block is kinda long, but I promise there is a short explanation at the bottom.</div> <div>Notice the ^^ symbol. It sends the output from the parser  combinator into my mapping function(anonymous). And I just create the case class.There is also an evaluator at the and...but that's in part 2.<h4><a href="/posts/2012-08-30-creating-a-language-2.html">next -> Part 2: something that kinda works</a></h4></div>