---
title: Making a programming language: Part 5 - variables and decisions
---

<table cellpadding="0" cellspacing="0" style="float: right; margin-right: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><div><div><div><div><div><div><div><div><div><div><div><a href="http://commons.wikipedia.org/wiki/File%3AStdstreams-notitle.svg" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="A typical text terminal produces input and dis..." border="0" class="zemanta-img-inserted" height="184" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Stdstreams-notitle.svg/300px-Stdstreams-notitle.svg.png" style="border: none; font-size: 0.8em;" width="300" /></a></div></div></div></div></div></div></div></div></div></div></div></td></tr><tr><td style="text-align: center; width: 300px;">A typical text terminal produces input and displays output and errors (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3AStdstreams-notitle.svg" target="_blank">Wikipedia</a>)</td></tr></tbody></table><a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Table of contents</a><span style="background-color: white; color: #222222; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;">, </span><a href="https://github.com/edofic/scrat-lang" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Whole project on github</a><br /><br /><div style="text-align: justify;">In <a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-4.html" target="_blank">Part 4</a> I managed to create a <a href="http://en.wikipedia.org/wiki/Hello_world_program" rel="wikipedia" target="_blank" title="Hello world program">Hello World</a>. What's the next program after this in every programming tutorial? A program that asks your name and greets you. Greeter perhaps?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Reading from <a href="http://en.wikipedia.org/wiki/Standard_streams" rel="wikipedia" target="_blank" title="Standard streams">standard input</a> in pretty trivial, just wrapping up readLine <a href="http://en.wikipedia.org/wiki/Function_%28mathematics%29" rel="wikipedia" target="_blank" title="Function (mathematics)">function</a> from scala, see previous post on how this is done. And I called this function readln.</div><br /><h3>Variables</h3>I could cheat a bit and write something like this <br /><pre>println("who are you?")<br />println("hello", readln())<br /></pre><div style="text-align: justify;">since I don't really have to store the name. This works but I also want to make a program that responds differently to different input, e.g. simplified authentication. So I want to store the input. Something like</div><pre>print("enter passcode")<br />input = readln()<br /></pre>So I first create a case class to represent this <br /><pre>case class Assignment(to: Identifier, from: Expression) extends Expression<br /></pre>parsing isn't that hard either <br /><pre>private def assignment: Parser[Assignment] = identifier ~ "=" ~ expr ^^ {<br />  case id ~ "=" ~ exp => Assignment(id, exp)<br />}<br /><br />private def expr: Parser[Expression] = sum ||| assignment<br /></pre>Notice again my abuse of ||| where reverse order would have sufficed, don't do that.<br /><br /><div style="text-align: justify;">Evaluation...here I had to make a choice. Where to put the assigned variables. In the same bucket as constants. <a href="http://en.wikipedia.org/wiki/Global_variable" rel="wikipedia" target="_blank" title="Global variable">Global variables</a> ARE evil but I don't care since I'm having fun and I do it anyway. Don't worry this changes when I introduce function definitions and objects.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So StdLib became ScratRuntime and has a mutable map for storing values of identifiers. Full source <a href="https://github.com/edofic/scrat-lang/blob/51008205be59ec325dcb1de2f1058071c1703f4a/main/src/com/edofic/scrat/Runtime.scala" target="_blank">here</a> if you're interested. Of course some changes had to be made because of this refactoring. Full commit diff <a href="https://github.com/edofic/scrat-lang/commit/51008205be59ec325dcb1de2f1058071c1703f4a" target="_blank">here</a>.</div><br />Evaluation of assignment is now simple map put <br /><pre>case Assignment(name, exp) => {<br />  val e = apply(exp)<br />  runtime.identifiers.put(name.id, e)<br />  e<br />}<br /></pre>The expression returns the assigned value so you can do a=b=1(in fact I didn't try that yet)<br /><br /><h3>What if</h3><div><div style="text-align: justify;">If expressions. I wasn't in the mood for parentheses or brackets so I went ruby style. Except my expressions are single line only(for now) so I had to put everything in one line. I needed a separator between the <a href="http://en.wikipedia.org/wiki/Predicate_%28grammar%29" rel="wikipedia" target="_blank" title="Predicate (grammar)">predicate</a> and positive value and as an added bonus I didn't need the "end". So not much like ruby anymore but it was good inspiration. </div></div><div><div style="text-align: justify;">I considered booleans but ultimately I can implement everything still in doubles(too much work to make  whole <a href="http://en.wikipedia.org/wiki/Type_system" rel="wikipedia" target="_blank" title="Type system">type system</a> of primitives when you can have just one type). Zero is False and everything else is True. So AND becomes * and OR becomes -. I'll add some equality so I can compare strings too.</div></div><div><div style="text-align: justify;">I didn't need inequalities until now(didn't even think about before writing this post) so they aren't in the language yet.</div></div><div style="text-align: justify;">Sample if expression</div><pre>if input1*input2 then "okay" else "nooooooo"<br /></pre>See, no parens. And I was inspired by scala to make the else part mandatory.<br /><br /><div style="text-align: justify;">So how do I implement this? Case class is quite trivial, it has tree expressions: predicate, true value and false value. Evaluation just evaluates the predicate(recursion!!) and then evaluates and returns the appropriate expression </div><pre>case IfThenElse(pred, then, els) => apply(pred) match {<br />  case d: Double => if (d != 0) apply(then) else apply(els)<br />  case other => throw new ScratInvalidTypeError("expected a number, got "<br />                                                   + other)<br />}<br /></pre>That error is just a class that extends exception.  <br />I added some more case classes and evaluation cases for Equals and NotEquals. They're very simple so I won't include them here(<a href="https://github.com/edofic/scrat-lang/commit/97312113282b484fa53357f61fb05990da0cd3ea" target="_blank">diff on github</a>)<br />Parsing on the other hand is more interesting, here's the changed part. <br /><pre>private def ifThenElse: Parser[IfThenElse] =<br />  "if" ~ expr ~ "then" ~ expr ~ "else" ~ expr ^^ {<br />  case "if" ~ predicate ~ "then" ~ then ~ "else" ~ els => IfThenElse(predicate, then, els)<br />}<br /><br />private def equality: Parser[Expression] = <br />  noEqExpr ~ rep(("==" | "!=") ~ noEqExpr) ^^ {<br />  case head ~ tail => {<br />    var tree: Expression = head<br />    tail.foreach {<br />      case "==" ~ e => tree = Equals(tree, e)<br />      case "!=" ~ e => tree = NotEquals(tree, e)<br />    }<br />    tree<br />  }<br />}<br /><br />private def noEqExpr: Parser[Expression] = sum ||| assignment ||| ifThenElse<br /><br />private def expr = noEqExpr ||| equality<br /></pre><table cellpadding="0" cellspacing="0" style="float: right; text-align: right;"><tbody><tr><td style="text-align: center;"><div><div><div><div><a href="http://www.flickr.com/photos/90863480@N00/4947839133" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="layers" border="0" class="zemanta-img-inserted" height="212" src="http://farm5.static.flickr.com/4074/4947839133_086f0266e4_m.jpg" style="border-bottom-style: none; border-color: initial; border-image: initial; border-left-style: none; border-right-style: none; border-top-style: none; border-width: initial; font-size: 0.8em;" width="320" /></a></div></div></div></div></td></tr><tr><td style="text-align: center; width: 240px;">layers (Photo credit: <a href="http://www.flickr.com/photos/90863480@N00/4947839133" target="_blank">theilr</a>)</td></tr></tbody></table><div style="text-align: justify;">I finally got around to understand grammars a bit more. In order to make the grammar not ambiguous an not left recursive you stack layers upon layers. Like onion.  And you use these layers to separate layers of precedence - most lightly binding operations being the upper layer(expr). This gets rid of ambiguity. And you can also use these layers to deal with recursion. Something in a deeper layer can contain an item from a higher layer - thus recursion - but it must first match something to avoid infinite recursion.  And that's it. This is very well explained on <a href="https://www.coursera.org/compilers" target="_blank">compilers course on Coursera</a> and I thought I understood the (very abstract) explanation but the evidence says I did not until I had some hands on experience.<br /><br />A quick sample in scrat to finish it of<br /><pre>print("enter passcode")<br />pass = "password"<br />state = if readln()==pass then "granted" else "denied"<br />println("access", state)<br /></pre><br /></div><div style="text-align: justify;"><b>next <a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-6.html" target="_blank">implementing user defined functions</a></b></div>