---
title: Chaining implicit conversion in scala
---

Today I was hanging in the #<a class="zem_slink" title="Scala (programming language)" href="http://www.scala-lang.org/" target="_blank" rel="homepage">scala</a> <a class="zem_slink" title="Internet Relay Chat" href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" target="_blank" rel="wikipedia">IRC channel</a> and somebody came along(forgot the nick, sorry) and asked about some <a class="zem_slink" title="Compilation error" href="http://en.wikipedia.org/wiki/Compilation_error" target="_blank" rel="wikipedia">compilation error</a>. I deduced he was trying to chain implicit conversions. And this doesn't work. Else compilation would take forever and would also compile some wrong code by inserting long strings of implicits. But then somebody else responded(I think nick started with d) and gave a solution to implicit chaining. But I'm not giving it away yet, you'll have to read a bit more.
<h1>The problem</h1>
Let's say I have some <a class="zem_slink" title="Class (computer programming)" href="http://en.wikipedia.org/wiki/Class_%28computer_programming%29" target="_blank" rel="wikipedia">classes</a> that just add semantics to values(think labeled boxes)
<pre lang="scala">case class Foo(a: Int)
case class Bar(b: Int)
case class Baz(c: Int)</pre>
And because they look similar we may want to do some <a class="zem_slink" title="Type conversion" href="http://en.wikipedia.org/wiki/Type_conversion" target="_blank" rel="wikipedia">implicit conversion</a>. Let's say that that's needed is conversion from Bar to Foo and from Baz to Bar.
<pre lang="scala">implicit def bar2foo(bar: Bar) = Foo(bar.b)
implicit def baz2bar(baz: Baz) = Bar(baz.c)</pre>
On a level this also implies that Baz can be seen as Foo. But when you try it
<pre lang="scala">println(foo.a)
println(bar.a)
println(baz.a)</pre>
you get a compile error
<pre>Implicits.scala:18: error: value a is not a member of Implicits.Baz
println(baz.a)
^
one error found</pre>
<h1>The solution</h1>
As said, scala <a class="zem_slink" title="Compiler" href="http://en.wikipedia.org/wiki/Compiler" target="_blank" rel="wikipedia">compiler</a> doesn't try to traverse the graph of implicit conversions and therefore doesn't figure out how to insert needed conversions here. But here lies a handy catch. What if the conversion wasn't from Bar to Foo but from something Bar-like to Foo. Then the compiler would know that this chaining is intended and is (probably) not a dead end. Good news: scala lets you express that. It's called a view bound. You make the method generic and limit input type to something that can be seen(implicitly converted to) as a Bar. Here's the code.
<pre lang="scala">implicit def bar2foo[T &lt;% Bar](bar: T) = Foo(bar.b)</pre>
All the magic lies in the &lt;% operator. That's the view bound. When you type baz.a the compiler sees that a property is available on the Foo class and that there's an implicit conversion to Foo from something Bar-like. Fortunately there's a conversion from Baz to Bar in scope so it can invoke the method. Inside the method it tries to get the b property from baz but it's not available. So it checks the conversions and sees that a conversion from Baz to Bar exists in the scope and it satisfies the need for b. It inserts this conversions and compilation happily chucks along.

[caption id="attachment_37" align="alignleft" width="300"]<img class="size-medium wp-image-37 " alt="Nest all the implicit conversions!" src="http://www.edofic.com/wp-content/uploads/2012/12/32096842-300x225.jpg" width="300" height="225" /> Nest all the implicit conversions![/caption]

Please don't do that. Implicits can make code hard to read even without nesting. So use with care. Scala is a very powerful language but great power comes with great responsibility.
