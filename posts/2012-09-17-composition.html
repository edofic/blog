---
title: Pretty function composition in scala and asynchronous function composition on android
---

<h3 style="text-align: center;">Composition</h3>
<table style="margin-left: auto; margin-right: auto; text-align: center;" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td style="text-align: center;">
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div><a style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;" href="http://commons.wikipedia.org/wiki/File%3ASurjective_composition.svg"><img class="zemanta-img-inserted" style="border: none; font-size: 0.8em;" alt="Surjective composition: the first function nee..." src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Surjective_composition.svg/300px-Surjective_composition.svg.png" width="200" height="133" border="0" /></a></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div></td>
</tr>
<tr>
<td style="text-align: center; width: 300px;">Surjective composition: the first function need not be surjective. (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3ASurjective_composition.svg" target="_blank">Wikipedia</a>)</td>
</tr>
</tbody>
</table>
Function composition is a nice way to sequence transformations on data. For example in a <a title="Compiler" href="http://en.wikipedia.org/wiki/Compiler" target="_blank" rel="wikipedia">compiler</a> you take your source, <a title="Parsing" href="http://en.wikipedia.org/wiki/Parsing" target="_blank" rel="wikipedia">parse</a>, check, optimize and generate code(in a nutshell). It's a linear series of transformations -&gt; perfect for <a title="Function composition" href="http://en.wikipedia.org/wiki/Function_composition" target="_blank" rel="wikipedia">function composition</a>
In <a title="Haskell (programming language)" href="http://haskell.org/" target="_blank" rel="homepage">Haskell</a> you can use this beautiful <a title="Syntax" href="http://en.wikipedia.org/wiki/Syntax" target="_blank" rel="wikipedia">syntax</a>
<pre>compile = parse . check . optimize . codegen</pre>
leaving out the parameter(as it can be infered) and noting composition as "." which kinda looks like ° used in math(if you squint a bit).
In scala you could do something like
<pre>val compile = parse compose check compose optimize compose codegen</pre>
Nearly there, I just want it to look a bit prettier. (Compose is a method defined on Function1 trait)
So I define an <a title="Type conversion" href="http://en.wikipedia.org/wiki/Type_conversion" target="_blank" rel="wikipedia">implicit conversion</a> from function to "composable"
<pre>implicit def function2composable[A,B](f: A=&gt;B) = new AnyRef{
  def --&gt;[C](g: B=&gt;C) = v =&gt; g(f(c))
}</pre>
This creates an object and reimplements "compose" but I really like the syntax:
<pre>compile = parse --&gt; check --&gt; optimize --&gt; codegen</pre>
<a title="Functional programming" href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="wikipedia">Functional programming</a> can be imagined as a <a href="http://swizec.com/blog/my-brain-cant-handle-oop-anymore/swizec/4320" target="_blank">waterfall of data</a>, flowing from one function into the next, and the --&gt; operator represents this nicely.

Let's go a step further. If the composition is one-off, and this is a waterfall of <a title="Data" href="http://en.wikipedia.org/wiki/Data" target="_blank" rel="wikipedia">DATA</a> it could be nice to represent that.
Something like
<pre>result = source --&gt; parse --&gt; check --&gt; optimize --&gt; codegen</pre>
So now I'm taking a value and sending it through black boxes. Very nice. Apart from the fact it doesn't work(yet!).
<pre>implicit def any2waterfall[A](a: A) = new AnyRef{
  def --&gt;[B](f: A=&gt;B) = f(a)
}</pre>
<a title="Scala (programming language)" href="http://www.scala-lang.org/" target="_blank" rel="homepage">Scala</a>'s awesome compiler can handle two implicit conversions with same method names. Nice.
You can even mix and match
<pre>result = source --&gt; (parse --&gt; check --&gt; optimize) --&gt; codegen</pre>
This does the composition of parse, check and optimize into an anonymous function, applies it to the source and then applies codegen to it's result.
<h3>Goin async</h3>
<table style="float: right; margin-right: 1em; text-align: right;" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td style="text-align: center;">
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div><a style="margin-bottom: 1em; margin-left: auto; margin-right: auto;" href="http://www.crunchbase.com/product/android"><img class="zemanta-img-inserted" style="border: none; font-size: 0.8em;" alt="Image representing Android as depicted in Crun..." src="http://www.crunchbase.com/assets/images/resized/0001/4601/14601v1-max-450x450.png" width="153" height="55" border="0" /></a></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div></td>
</tr>
<tr>
<td style="font-size: 13px; text-align: center; width: 153px;">Image via <a href="http://www.crunchbase.com/" target="_blank">CrunchBase</a></td>
</tr>
</tbody>
</table>
<div>What about asynchronous calls? Can I compose those too? I think it's possible with Lift actors(or with scalaz's?), but I needed to integrate that into <a title="Android" href="http://code.google.com/android/" target="_blank" rel="homepage">Android</a>'s activities quite recently. Well I did not *need* to do it, but it was quite a nice solution.</div>
<div>The usual way of doing things async in Android is with the conveniently named AsyncTask. The problem is - you can't subclass it in scala because of some compiler bug regarding varargs parameters. Silly.</div>
<div>So let's do a lightweight(in terms of code) substitution. We can "spawn a thread" using scala's actors. And activity can receive messages through a Handler.
<pre>import android.os.{Message, Handler}

trait MessageHandler {
  private val handler = new Handler {
   override def handleMessage(msg: Message) {
     react(msg.obj)
   }
  }

  def react(msg: AnyRef)

  def !(message: AnyRef) {
   val msg = new Message
   msg.obj = message
   handler.sendMessage(msg)
  }
}</pre>
So in an activity that mixes in MessageHandler I can post messages to my self. An I can do it async since Handler is thread safe
<pre>def react(msg: AnyRef) = msg match {
  case s: String = Toast(this, s, Toast.LENGTH_LONG).makeText()
  case _ =&gt; ()
}

...
//somewhere inside <a title="User interface" href="http://en.wikipedia.org/wiki/User_interface" target="_blank" rel="wikipedia">UI</a> thread
import actors.Actor.actor
val that = this
actor{
  val msg = doExpensiveWork()
  that ! msg
}
...</pre>
Not the most concise way to write it, but I believe the most clear one. Method doExpensiveWork is done in the background so it doesn't block UI and it posts the result back as a message.
<h4><a title="Asynchrony" href="http://en.wikipedia.org/wiki/Asynchrony" target="_blank" rel="wikipedia">Async</a> composition - finally</h4>
</div>
<div>What I want to do now is use function composition to do something like
<pre>(input --&gt; expensiveOne --&gt; expensiveTwo) -!&gt; displayResults</pre>
In other words, do "waterfall composition" in background using some input I have now and post the result back into the UI thread to method displayResults. That should be the magic of the -!&gt; operator. Do the left side in bg and post it to the right side async.
I need a new trait for that
<pre>trait MessageHandlerExec extends MessageHandler{ outer =&gt;
  override protected val handler = new Handler {
    override def handleMessage(msg: Message) = msg.obj match {
      case r: Runnable =&gt; r.run()
      case other: AnyRef =&gt; react(other)
    }
  }

  implicit def any2asyncComposable[A](a: =&gt; A) = new AnyRef{
    def -!&gt;[B](f: A=&gt;B) = outer ! new Runnable{
      def run() = f(a)
    }
  }
}</pre>
The trick here is using by-name parameters in the implicit conversion. This delays the execution of a(which in example above would be a waterfall and moves it into a worker thread.

</div>
