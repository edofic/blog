---
title: Cool Monday: Exploration of dynamic db acces from scala
---

I use <a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">scala</a> on <a href="http://www.t-mobile.com/shop/phones/?capcode=AGE" rel="tmobile" target="_blank" title="Android phones">Android</a> and I don't like the integrated database <a href="http://en.wikipedia.org/wiki/Application_programming_interface" rel="wikipedia" target="_blank" title="Application programming interface">API</a>. It's very verbose and very stateful. I had written my own <a href="http://en.wikipedia.org/wiki/Object-relational_mapping" rel="wikipedia" target="_blank" title="Object-relational mapping">ORM</a>(<a href="http://en.wikipedia.org/wiki/Data_access_object" rel="wikipedia" target="_blank" title="Data access object">DAO</a> would be a more appropriate tag) a while back, before I used scala but it's not enough anymore. So now I'm on a quest for a better database API. My dream is something small that handles schema for me and is <a href="http://en.wikipedia.org/wiki/Type_safety" rel="wikipedia" target="_blank" title="Type safety">type-safe</a>. A nice <a href="http://en.wikipedia.org/wiki/Digital_subscriber_line" rel="wikipedia" target="_blank" title="Digital subscriber line">DSL</a> that is converted to <a href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=45498" rel="homepage" target="_blank" title="SQL">SQL</a> at <a href="http://en.wikipedia.org/wiki/Compile_time" rel="wikipedia" target="_blank" title="Compile time">compile time</a>  and does code generation. So it's fast like hand writing everything. But reduces code footprint by an order of magnitude(at least). <a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">Scala</a> <a href="http://slick.typesafe.com/" target="_blank">SLICK</a> looks promising. It fits most requirements. But it's kinda big for android projects(you need scala library too!) and has not yet hit a stable version so I wouldn't be comfortable shipping it. Will definitely give it a thorough test when scala 2.10 is stable and SLICK is released. Oh, and it needs a third party <a href="http://en.wikipedia.org/wiki/JDBC_driver" rel="wikipedia" target="_blank" title="JDBC driver">JDBC  driver</a> for Android. This is another level of abstraction and therefore another source of slowness. I contemplated writing my own clone targeted at Android but   never came around to actually doing it(yet!). It seems like a herculean task for single developer working in spare time.<br /><br /><h2>Meanwhile</h2><div>Yesterday I stared thinking how <a href="http://en.wikipedia.org/wiki/Dynamic_programming_language" rel="wikipedia" target="_blank" title="Dynamic programming language">dynamic languages</a> handle databases. And I got an idea. Scala has type Dynamic that does compilation magic to provide syntactic sugar for working with dynamic languages or objects. Here's an idea: do queries in plain SQL and perform extraction of data in a dynamic way. </div><div>And how to do this? Just wrap up Cursor to provide necessary methods. </div><pre>class WrappedCursor(cursor: Cursor) implements Cursor{<br />  //delegated methods go here<br />}<br /></pre>Why I need this? Cake pattern of course, Dynamic cursor get's mixed in. <br /><pre>trait DynamicCursor extends Dynamic{ this: Cursor =><br /><br />  def selectDynamic(name: String) =<br />    getColumn(getColumnIndex(name))<br /><br />  def getColumn(index: Int) =<br />    getType(index) match {<br />    case Cursor.FIELD_TYPE_BLOB => getBlob(index)<br />    case Cursor.FIELD_TYPE_FLOAT => getDouble(index)<br />    case Cursor.FIELD_TYPE_INTEGER => getLong(index)<br />    case Cursor.FIELD_TYPE_NULL => null<br />    case Cursor.FIELD_TYPE_STRING => getString(index)<br />  }<br /><br />  def toSeq = (0 until getColumnCount) map getColumn<br />}<br /></pre>I targeted API level 14(Ice Cream Sandwich) since getType(method on Cursor) is available from 11 on.    Key method here is getColumn that abstracts over types. So you can read a column and  do pattern matching on it. Or you are evil and use implicit conversions from Any to String, Long etc... Or use implicit conversion to "converter"<br /><pre>implicit class Converter(val value: Any) extends AnyVal{<br />  def blob = value.asInstanceOf[Array[Byte]]<br />  def double = value.asInstanceOf[Double]<br />  def long = value.asInstanceOf[Long]<br />  def string = value.asInstanceOf[String]<br />}<br /></pre>But the real deal is selectDynamic. This allows you to write code like this<br /><pre>val c = new WrappedCursor(result) with DynamicCursor<br />c.someColumn.long</pre><div style="height: 15px; margin-top: 10px;">This compiles down to selectDynamic("someColumn") that calls getColumn and finally implicit conversion is inserted that allows for terse cast to Long.<br />And I threw in a conversion from row to Seq that does a snapshot of current row. This allows pattern matching on rows. Any you can now construct a Stream that will handle Cursor state and lazily evaluate and store these snapshots. Therefore you can abstract away all mutability and handle cursor as immutable collection.<br /><br />Said conversion to stream<br /><pre>def CursorStream(cursor: DynamicCursorRaw with Cursor) = {<br />  def loop(): Stream[Seq[Any]] = {<br />    if(cursor.isAfterLast)<br />      Stream.empty[Seq[Any]]<br />    else {<br />      val snapshot = cursor.toSeq<br />      cursor.moveToNext()<br />      snapshot #:: loop()<br />    }<br />  }<br />  cursor.moveToFirst()<br />  loop()<br />}<br /></pre>And some more implicits to help <br /><pre>implicit class RichCursorRaw(cursor: Cursor) extends AnyVal{<br />  def dynamicRaw = new WrappedCursor(cursor) with DynamicCursorRaw<br />  def toStream = CursorStream(dynamicRaw)<br />}<br /></pre>All the source is in the project on github <a href="https://github.com/edofic/dynamic-db-android">https://github.com/edofic/dynamic-db-android</a> (work in progress).<br /><br /><br />