---
title: Cool Monday: Scala Macros
---

<table cellpadding="0" cellspacing="0" style="float: right; margin-right: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://commons.wikipedia.org/wiki/File%3AGarden_flower_.jpg" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="Garden flower" border="0" class="zemanta-img-inserted" height="225" src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/Garden_flower_.jpg/300px-Garden_flower_.jpg" style="border: none; font-size: 0.8em;" width="300" /></a></td></tr><tr><td style="text-align: center; width: 300px;">Macro shot (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3AGarden_flower_.jpg" target="_blank">Wikipedia</a>)</td></tr></tbody></table>For me the highlight of this week was discovering Bootstrap. I heard of it before but never looked into it. Probably because I wasn't doing web stuff. The thing is bloody awesome. Back on topic.<br /><br /><a href="http://www.scala-lang.org/" rel="homepage" target="_blank" title="Scala (programming language)">Scala</a> 2.10 RC2 was released this Friday. Considering 2.9 had 3 RC releases, 2.10 final is probably quite near. And it brings some awesome features. One of them are <a href="http://en.wikipedia.org/wiki/Macro_%28computer_science%29" rel="wikipedia" target="_blank" title="Macro (computer science)">macros</a><br /><br /><h3>Macros</h3><div>So what are macros basically? Code executed at <a href="http://en.wikipedia.org/wiki/Compile_time" rel="wikipedia" target="_blank" title="Compile time">compile time</a>. And that's about it. </div><div>So what is so great about that? Well you can do AST modifications and stuff that gets quite into <a href="http://en.wikipedia.org/wiki/Compiler" rel="wikipedia" target="_blank" title="Compiler">compiler</a>-plugin territory in your regular code. That means you can do pretty advanced stuff and do abstraction with performance. Oh yeah, you can also do <a href="http://en.wikipedia.org/wiki/Type_system" rel="wikipedia" target="_blank" title="Type system">type checking</a> and emit compile-time errors. Safety first kids!</div><div><br /></div><h3>Usages</h3><div>SLICK uses macros(in the experimental <a href="http://en.wikipedia.org/wiki/Application_programming_interface" rel="wikipedia" target="_blank" title="Application programming interface">API</a>) to transform scala expressions into <a href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=45498" rel="homepage" target="_blank" title="SQL">SQL</a>. At compile time! ScalaMock uses it to provide more natural API for testing. As said, you can use it for <a href="http://en.wikipedia.org/wiki/Code_generation_%28compiler%29" rel="wikipedia" target="_blank" title="Code generation (compiler)">code generation</a> or validation at compile time. Good library design will be able to minimize <a href="http://en.wikipedia.org/wiki/Boilerplate_code" rel="wikipedia" target="_blank" title="Boilerplate code">boilerplate code</a> even further now. And some people will argue that macros make scala even harder language.</div><h3>Type Macros</h3><div>This is the best part for me. But unfortuntely it's not implemented yet. Or at least not dcumented. There are some methods with suspisious names in the API but no useful documentation. In all presentations this is referred to as "future work" but I still have my fingers crossed it makes it into final release.</div><div>So what's the fuss? Automatically generated types. Large scale code-gen. </div><div>As in ability to programatically create types at compile time. As a consequence you can create whole classes with bunch of methods. And I already have a <a href="http://en.wikipedia.org/wiki/Use_case" rel="wikipedia" target="_blank" title="Use case">use case</a> of my own. I want to make a typesafe ORM for Android that's super fast. I did <a href="https://github.com/edofic/YodaLib" target="_blank">YodaLib</a> ORM while back. It uses reflection(although it's fast enough usually) and provides a Cursor that lazily wraps rows into classes. And you need to make sure by hand that your class coresponds to columns of your result set. Not very safe. I had an idea to make static-typed safe inferface for the database when I first heard about HList. You would do projection as a <a href="http://www.edofic.com/2012/10/cool-monday-hlist-and-shapeless.html" target="_blank">HList</a> and result rows would be lazily wrapped into HLists. But using them for wrapping every row(possibly filling data in with reflection) would be a performance penalty. Not to mention a mess to implement. Now consider using a macro to generate code for wrapping. It would be no slower than accessing columns by hand. And a type macro would automatically create a case class for given projection. Heavens. I'm just waiting for official documentation on macros...this is a tempting project.</div><div>(oh yeah, it would manage your scema too, so you don't need to worry about consistency between your code and your schema)</div><h3>Documentation</h3><div>Here's <a href="http://scalamacros.org/" target="_blank">scalamacros.org</a> which gives some information. Also s<a href="http://scalamacros.org/talks/2012-04-28-MetaprogrammingInScala210.pdf" target="_blank">ome quite useful slides</a>. I hope now that 2.10 is in RC things stabilize, because in the milestone releases api was changing constantly. <a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html" target="_blank">Nightly API scaladoc</a>.... Proper documentation is apparently <a href="http://docs.scala-lang.org/sips/pending/self-cleaning-macros.html" target="_blank">coming soon</a>,</div><div><br /></div><div><h3>Le Code</h3><div>A use case for macros, loop unrolling.</div><div>Below is a trivial sample of repetitive code.</div></div><pre>class Manual{<br />    def show(n: Int){<br />        println("number "+n)<br />    }<br />    <br />    def code(){<br />        show(1)<br />        show(2)<br />        show(3)<br />        show(4)<br />        show(5)<br />    }<br />}<br /></pre>We can deal with repetition writing a loop. (<a href="http://en.wikipedia.org/wiki/Higher-order_function" rel="wikipedia" target="_blank" title="Higher-order function">Higher order function</a> really)<br /><pre>for( i <- 1 to 5 ) show(i)<br /></pre>But this doesnt generate the same AST(and bytecode)!<br />Protip: use <br /><pre>scalac -Xprint:parser -Yshow-trees Manual.scala</pre>to see AST after parsing.<br />Sometimes(rarely!) you want to unroll the loop to produce same <a href="http://en.wikipedia.org/wiki/Bytecode" rel="wikipedia" target="_blank" title="Bytecode">byte code</a> as typing all the iterations by hand.<br /><pre>Macros.unroll(1,5,1)(show)</pre>With a proper unroll macro defined. I spent an hour to come up with this implementation...and then scalac started crashing on me... Is there something terrible in my code?<br />I gave up and went on to do useful stuff...But macros hear me! I'll be back. <br /><pre>import reflect.macros.{Context}<br />import scala.language.experimental.macros<br /><br />object Macros {<br />  def unroll(start: Int, end: Int, step: Int)(body: Int => Unit) = <br />    macro unrollImpl<br /><br />  def unrollImpl(c: Context)(start: c.Expr[Int] ,end: c.Expr[Int], step: c.Expr[Int])(body: c.Expr[Int => Unit]): c.Expr[Any] = {<br />    import c.universe._<br />    val Literal(<a href="http://en.wikipedia.org/wiki/Constant_%28programming%29" rel="wikipedia" target="_blank" title="Constant (programming)">Constant</a>(start_value: Int)) = start.tree<br />    val Literal(Constant(end_value: Int)) = end.tree<br />    val Literal(Constant(step_value: Int)) = step.tree<br /><br />    val invocations = Range(start_value, end_value, step_value) map { n =><br />      val n_exp = c.Expr(Literal(Constant(n)))<br />      reify{<br />        ((body.splice)(n_exp.splice))<br />      }.tree<br />    }<br />    c.Expr(Block(invocations:_*))<br />  }<br />}<br /></pre><div style="margin-top: 20px; overflow: hidden;">