---
title: Cool Monday: Hindley-Milner on a dynamic language
---

<div>So I'm getting into type theory. Slowly. Note to self: read a proper book on this topic. I'm getting familiar with it through some practical applications. Namely scala and haskell. </div><div>That same <a href="http://www.edofic.com/2012/10/design-patterns-are-bullshit.html" target="_blank">discussion about design patterns</a> also included dynamic vs <a href="http://en.wikipedia.org/wiki/Type_system" rel="wikipedia" target="_blank" title="Type system">static typing</a>. And I asked twitter about it. <a href="https://twitter.com/HairyFotr" target="_blank">HairyFotr</a> link this <a href="http://screencasts.chariotsolutions.com/uncovering-the-unknown-principles-of-type-inference-" target="_blank">amazing talk about type inference</a> to me. Basically there are two conclusions to be drawn</div><div><ul><li>Every static typed language should have at least limited type <a href="http://en.wikipedia.org/wiki/Inference" rel="wikipedia" target="_blank" title="Inference">inference</a>. It's compiler's job to do so and quite trivial to implement.</li><li>Properly done static typed language provides all features the that dynamic typed languages can. Safely.</li></ul><div>As I'm (still) <a href="http://www.edofic.com/2012/08/making-programming-language-part-1-how.html" target="_blank">implementing a language</a> that happens to be dynamic(because I was too lazy to look-up how to do type checking) second point interests me more. </div></div><div><br /></div><div>Can I turn my language into a static one without changing syntax(adding type annotations) and losing features? That would be awesome!</div><div>After a day of thinking, answer seems to be <b>YES!</b><br /><h3>Global type inference in a nutshell</h3></div><div>So I want a dynamic-like syntax(no types anywhere). Good news is I don't have nominal types, so I can use inference to get structural types. </div><div>Java, C# and many other mainstream languages use <a href="http://en.wikipedia.org/wiki/Nominative_type_system" rel="wikipedia" target="_blank" title="Nominative type system">nominal typing</a> at the level of the vm. This means that type A is a subtype of type B precisely when name of A is a subtype of name ob B. For example </div><div><pre>interface <a href="http://en.wikipedia.org/wiki/Foobar" rel="wikipedia" target="_blank" title="Foobar">Foo</a>{<br />    void <a href="http://en.wikipedia.org/wiki/Method_%28computer_programming%29" rel="wikipedia" target="_blank" title="Method (computer programming)">method</a>(int a);<br />}<br /><br /><br />interface Bar{<br />    void method(int b);<br />}</pre>If you have a method that takes in an instance of Foo, you cannot pass an instance of Bar. Because Bar isn't subtype of Foo. Even though they are <a href="http://en.wikipedia.org/wiki/Structure" rel="wikipedia" target="_blank" title="Structure">structurally</a> the same. Fun fact: because <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine" rel="wikipedia" target="_blank" title="Java Virtual Machine">JVM</a> is designed like this, scala cannot have global type inference.<br />See, global inference(or "<a href="http://en.wikipedia.org/wiki/Type_inference" rel="wikipedia" target="_blank" title="Type inference">type reconstruction</a>") looks at usages and reconstructs properties and structure.  Another example<br /><pre>a = b.c + 1<br /></pre>That would be legal scrat code(or python, ruby or many other things). You take b's property named c, add one to it and assign the result to a. So b must have property c. That's the first structural requirement. From the + operator you can see that this c must be numeric. And from this follows that a is also numeric as it's the result of this computation.<br />If this were a body of a method and b it's parameter, type requirement for be would be(in made up syntax) b: { c: Number } - object with member of Number type. But that doesn't give you no class names.<br />So why is this <b>global </b>inference? It goes through the whole block of code(usually a function body) and puts in stub types where it doesn't have enough info and then solves the system of <a href="http://en.wikipedia.org/wiki/Requirement" rel="wikipedia" target="_blank" title="Requirement">requirements</a> and substitutes back.<br /><h3>Possible problems</h3></div><div>First of all, I have objects. This means I have to reconstruct object structure. This shouldn't be too bad. And you can quite easily figure out that A is subtype of B if set of requirements for A is a superset of requirements for B. </div><div>Then there's "mutable types". I concluded that following code should be illegal</div><pre>a = 1<br />a = "two"<br /></pre><div>as type of a should remain the same as in first assignment. This lets you reason about the code much more. But there's a hidden mutability. I use regular functions as object constructors returning a keyword "this" that evaluates to current scope. But throughout the body you still access this scope and it's type(it's an object after all) changes with every new (first) assignment and function definition. But this should be tracked through all possible code paths. Only problem is an if expression. Type of an if(and it's side-effects) can only be common super type of both then and else branch - an intersection of requirement sets. In a dynamic language you can reason about conditions and conclude when something should definitely be in scope and use it. Automatic reasoning about conditions? This could turn out tricky. Perhaps in later implementation.<br />An there's third an final problem(that I can see). Infinite types. I have not seen a practical usage but it doesn't work and that bothers me. Dynamic code in scrat just works, but same code translated to haskell yields a compiler error - "can't instantiate infinite type". But apparently infinite types can be detected, so maybe I can find a way to present them and it will compile. More about this soon.<br /><h3>Conclusion</h3>There are some problems but I believe I can make it work. It would be super awesome to have a language that feels dynamic but gives you all benefits of static typing. Compilers should do the hard work after all! And they should be capable of inferring general enough types that all correct programs type check.<br />Or am I missing some important aspect that works only with dynamic types?<br /><br />Otherwise...code coming soon.</div><div style="margin-top: 20px; overflow: hidden;">