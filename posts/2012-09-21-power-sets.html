---
title: Power sets
---

<div style="text-align: right;"></div>
It all started out when a friend of mine(<a href="http://naspletu.org/" target="_blank">check him out</a>) told me a story about someone having an interview at <a title="Google" href="http://google.com/" target="_blank" rel="homepage">Google</a>. He was <a title="Live coding" href="http://en.wikipedia.org/wiki/Live_coding" target="_blank" rel="wikipedia">live coding</a> and asked to implement a function that computes a <a title="Power set" href="http://en.wikipedia.org/wiki/Power_set" target="_blank" rel="wikipedia">power set</a> of a given set. He totaly over-engineered it and after an hour of fiddling came up with 4-liner in python. Ok. Big deal. How hard can it be? I immediately started to brainstorm a solution of my own(and Matevž helped). Paraphrased train of thought below.

So what is a power set? Say a power set of set A. It's a set of all <a title="Subset" href="http://en.wikipedia.org/wiki/Subset" target="_blank" rel="wikipedia">subsets</a> of A. It's all possible combinations of including and excluding single elements. So it's like applying filters to the original set. Wait a sec, a set of size n has 2 to the n-th power subsets. It all matches up. N-bit number are said filters. So you count from 0 to 2^n-1 you enumerate exactly all the filters and therefore all the subsets. You just calculated the power set. This took about 30sec in real time.

Another minute to sketch the implementation.
You implement set as Lists. Let's say <a title="Java (programming language)" href="http://www.oracle.com/technetwork/java/" target="_blank" rel="homepage">Java</a> is the language of choice. An
y reasonable input would be shorter than 64 elements, at least on current machinery. So long can be used as counter. And now a nested for loop to iterate over elements and appending them if counter &amp;&amp; (1 &lt;&lt; n). Simple.

Won't post the code since I never wrote it.
<h3>The original blogpost</h3>
<div style="height: 15px; margin-top: 10px;">This happened in a lab at Faculty for Computer and Information science. On my way home I started thinkking....what is that 4-line implementation? It can't be my algorithm, that won't fit - it just isn't that elegant. Matevž also told me who was the original author and it was someone whose blog I was subscribed to(I still am, it's pretty awesome, <a href="http://swizec.com/" target="_blank">check it out</a>). So I searched for the original blogpost. And <a href="http://swizec.com/blog/a-google-phone-interview/swizec/3813" target="_blank">found it</a>. It wasn't four lines. 
<pre>def powerset(set):
      binaries = [bin(a) for a in range(2^len(set))]
      power = []
      for yeses in binaries:
        subset = []
 yeses = str(yeses)
 for i in range(len(yeses)):
                 if yeses[i] == “1”:
          subset.append(set[i])
 power.append(subset)
      return power</pre>
But more importantly, it's essentially my algorithm. (And it didn't took him an hour, read the post, it's interesting)

And then I realised. This is ugly. Quite ugly. It may be efficient and allow for doing iteration and evaluating it lazily, but oh boy it's ugly. Can't it be done in a simpler way?
<h4>Recursive solution</h4>
<div>So by asking how I <b>compute</b> a power set I obtained the imperative algorithm above.</div>
<table style="float: right; margin-left: 1em; text-align: right;" cellspacing="0" cellpadding="0" align="center">
<tbody>
<tr>
<td style="text-align: center;">
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div><a style="margin-bottom: 1em; margin-left: auto; margin-right: auto;" href="http://commons.wikipedia.org/wiki/File%3ABalanced_tree.png"><img class="zemanta-img-inserted" style="border: none; font-size: 0.8em;" alt="Balanced tree" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/33/Balanced_tree.png/300px-Balanced_tree.png" width="200" height="138" border="0" /></a></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div></td>
</tr>
<tr>
<td style="font-size: 13px; text-align: center; width: 300px;">Balanced tree (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3ABalanced_tree.png" target="_blank">Wikipedia</a>)</td>
</tr>
</tbody>
</table>
<div> Time to change the question. What <b>is</b> a power set?</div>
<div>It's a set of leaves of a balanced binary decision tree. Every inner node represents a decision to either take or leave out the element at respective index(I assume elements are indexed). That is root node responds to first element, it's children to second element, etc. Every leaf can be computed by following the decision path.  It's a <b>recursive</b> structure. So the tree can be decomposed to left and right subtree and recombined. An this is repeated until you get to leaves. So a power set of A is an union of the power set of "A minus the first element" and the same power set again but with every subset added the first element. Subtrees are represented by the two powersets and the recombination by adding head element to one set of sets and then doing the union. And to stop the recursion: power set of an empty set is a set containing just an empty set.</div>
<div>My attempt to formally express what I just written:</div>
<div></div>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://latex.codecogs.com/gif.download?A&amp;space;=&amp;space;%5C%7Ba_%7B1%7D,&amp;space;a_2%7B2%7D,&amp;space;...&amp;space;,&amp;space;a_%7Bn%7D%5C%7D&amp;space;%5Cnewline&amp;space;%5Cnewline&amp;space;P(A)&amp;space;=&amp;space;%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D&amp;space;%5C%7B&amp;space;%5C%7B%5C%7D&amp;space;%5C%7D&amp;space;&amp;&amp;space;;&amp;&amp;space;A=%5C%7B%5C%7D%5C%5C&amp;space;P(A-a_%7B1%7D)&amp;space;%5Cbigcup&amp;space;%5C%7B&amp;space;s&amp;space;%5Cbigcup&amp;space;a_%7B1%7D&amp;space;%7C&amp;space;s&amp;space;%5Cepsilon&amp;space;P(A-a_%7B1%7D)%5C%7D&amp;space;&amp;&amp;space;;&amp;space;&amp;&amp;space;otherwise&amp;space;%5Cend%7Bmatrix%7D%5Cright."><img alt="" src="http://latex.codecogs.com/gif.download?A&amp;space;=&amp;space;%5C%7Ba_%7B1%7D,&amp;space;a_2%7B2%7D,&amp;space;...&amp;space;,&amp;space;a_%7Bn%7D%5C%7D&amp;space;%5Cnewline&amp;space;%5Cnewline&amp;space;P(A)&amp;space;=&amp;space;%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D&amp;space;%5C%7B&amp;space;%5C%7B%5C%7D&amp;space;%5C%7D&amp;space;&amp;&amp;space;;&amp;&amp;space;A=%5C%7B%5C%7D%5C%5C&amp;space;P(A-a_%7B1%7D)&amp;space;%5Cbigcup&amp;space;%5C%7B&amp;space;s&amp;space;%5Cbigcup&amp;space;a_%7B1%7D&amp;space;%7C&amp;space;s&amp;space;%5Cepsilon&amp;space;P(A-a_%7B1%7D)%5C%7D&amp;space;&amp;&amp;space;;&amp;space;&amp;&amp;space;otherwise&amp;space;%5Cend%7Bmatrix%7D%5Cright." border="0" /></a></div>
<div>Now let's do that in code, my language of choice now is scala
<pre>def power[A](set: List[A]): List[List[A]] = set match {
    case Nil =&gt; List(Nil)
    case head::tail =&gt; power(tail) flatMap (set =&gt; List(set, head::set))
}</pre>
Yay just four lines. and the last one barely matters. But I can do even better. The same code in haskell
<pre>power [] = [[]]
power (head:tail) = power tail &gt;&gt;= \set -&gt;[set, head:set]</pre>
Both code snippets don't comply exactly to the equation. I swapped in flat-map instead of union. It gets rid of repetition(but I don't know the math notation, sadly). So you apply the lambda that creates both sides of the union to your list and then flatten it to produce the same result.

This code may look a bit cryptic at first sight but once you parse the syntax you can grasp the intention much more quickly than the imperative version. At least I can. Recursion is quite nice once you get used to it.
