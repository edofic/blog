---
title: Making a programming language: Part 6 - functions
---

<table cellpadding="0" cellspacing="0" style="float: right; margin-right: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><div><div><div><div><div><div><div><div><div><a href="http://commons.wikipedia.org/wiki/File%3AFunction_illustration.svg" style="margin-bottom: 1em; margin-left: auto; margin-right: auto; text-align: clear:right;"><img alt="Illustration of Function (mathematics)." border="0" class="zemanta-img-inserted" height="200" src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Function_illustration.svg/200px-Function_illustration.svg.png" style="border: none; font-size: 0.8em;" width="200" /></a></div></div></div></div></div></div></div></div></div></td></tr><tr><td style="text-align: center; width: 200px;">Illustration of Function (mathematics). (Photo credit: <a href="http://commons.wikipedia.org/wiki/File%3AFunction_illustration.svg" target="_blank">Wikipedia</a>)</td></tr></tbody></table><a href="http://edofic.blogspot.com/2012/08/making-programming-language-part-1-how.html" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Table of contents</a><span style="background-color: white; color: #222222; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;">, </span><a href="https://github.com/edofic/scrat-lang" style="background-color: white; color: #888888; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;" target="_blank">Whole project on github</a><br /><br />Long overdue, I'm finally writing about the most interesting part - <a href="http://en.wikipedia.org/wiki/User-defined_function" rel="wikipedia" target="_blank" title="User-defined function">user defined functions</a>. Objects should be in the next post as they are a natural extension of what I'm about to do. And because I'm to lazy to write a post that long.<br /><h3>What's a function?</h3><div>A function is something that takes parameters and returns a result. And I'm opting for side-effects as this is simpler to get something working that doing the whole <a href="http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29" rel="wikipedia" target="_blank" title="Referential transparency (computer science)">referential transparency</a> and <a href="http://en.wikipedia.org/wiki/Io_%28programming_language%29" rel="wikipedia" target="_blank" title="Io (programming language)">IO</a> <a href="http://en.wikipedia.org/wiki/Monad_%28functional_programming%29" rel="wikipedia" target="_blank" title="Monad (functional programming)">monad(Haskell)</a>. Although it would be interesting to have sort of <a href="http://en.wikipedia.org/wiki/Type_system" rel="wikipedia" target="_blank" title="Type system">dynamically typed</a> <a href="http://haskell.org/" rel="homepage" target="_blank" title="Haskell (programming language)">Haskell</a> thingy...maybe in the future. </div><div>So - <a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" rel="wikipedia" target="_blank" title="Side effect (computer science)">side-effect</a>-ful functions mean function body is a block of expressions, not just an expression, if I'm to do useful side-effects. This also means I want <a href="http://en.wikipedia.org/wiki/Scope_%28computer_science%29" rel="wikipedia" target="_blank" title="Scope (computer science)">lexical scope</a>. </div><h4>Body scope</h4><div>Let's think about that. A function body needs a scope. It's parent scope is kinda obvious - it's the scope in which the function was defined. I want closures! It's <a href="http://en.wikipedia.org/wiki/Local_variable" rel="wikipedia" target="_blank" title="Local variable">local scope</a> gets kinda tricky. I implemented read-only cascading and shadowing on write. If expressions can also have side-effects. So in different executions a parent variable may be shadowed or not. This means I cannot reuse the body scope, as the shadows need to be cleaned out(I'm considering an implementation that reuses it currently, but that's another story). As I'm not after performance I can simply create a new scope for each invocation of the function. </div><div>Parameters can be implemented as regular variables pre-put into the local scope before executing the function body. </div><h3>Parsing</h3><div>That was the hardest part. I had quite some problems in my grammar as I tried to introduce blocks. Mostly ambiguity and infinite recursion. I'll just post the interesting bits here - see <a href="https://github.com/edofic/scrat-lang/commit/181d513801567cb51e7ebc5637d1a64913290b13" target="_blank">the full commit</a> if you're interested in details.</div><div>The function definition boils down to: <br /><pre>private def exprList: Parser[List[<a href="http://en.wikipedia.org/wiki/Regular_expression" rel="wikipedia" target="_blank" title="Regular expression">Expression</a>]] = repsep(expr, "\\n+".<br />private def block: Parser[List[Expression]] = <br />  """\{\n*""".r ~> exprList <~ """\n*\}""".<br />private def functionDef: Parser[FunctionDef] =<br />  "func" ~> identifier ~ ("(" ~> repsep(identifier, ",") <~ ")") ~ block ^^ {<br />    case id ~ args ~ body => FunctionDef(id, args, body)<br />  }<br /></pre>Oh yes, and since I use newlines as separators now, they aren't whitespace and I have to handle them explicitly. <br /><pre>override protected val <a href="http://en.wikipedia.org/wiki/Whitespace_character" rel="wikipedia" target="_blank" title="Whitespace character">whiteSpace</a> = """[ \t\x0B\f\r]""".r<br /></pre>And later on I added lambdas which have optional identifier - so the only shcange is opt(identifier) in the parser.<br /><h3>Evaluation</h3><div>It's just another node in the AST - a case class. <br /><pre>case class FunctionDef(name: <a href="http://en.wikipedia.org/wiki/Identifier" rel="wikipedia" target="_blank" title="Identifier">Identifier</a>, args: List[Identifier], body: List[Expression]) extends Expression<br /></pre></div>Now I needed something to execute the definition and create a <a href="http://en.wikipedia.org/wiki/Function_%28mathematics%29" rel="wikipedia" target="_blank" title="Function (mathematics)">function value</a> in the enclosing scope. (this is in Evaluator class)<br /><pre>def createFunFromAst(arglist: List[Identifier], <br />  body: List[Expression], scope: SScope): FunctionVarArg =<br />    (args: Any) => args match {<br />      case lst: List[Any] => {<br />        if (lst.length != arglist.length) {<br />          throw new ScratInvalidTypeError(<br />           "expected " + arglist.length + " arguments, but got " + lst.length)<br />        } else {<br />          val closure = new SScope(Some(scope))<br />          (arglist zip lst) foreach {<br />            t => closure.put(t._1.id, t._2)<br />          }<br />          apply(body)(closure)<br />        }<br />      }<br />      case other => throw new ScratInvalidTypeError(<br />        "expected list of arguments but got" + other)<br />    }</pre>So, what am I doing here? I'm taking a part of the function definition(all except name - which is optional in the definition and not needed here) and the parent scope and then returning "FunctionVarArg" which is the same as native functions in standard library. This new function relies heavily on scala's closures(this would not be possible in this way in java!).  First it checks if got a list of arguments(case clauses) or it throws an exception. Then it checks the arity. Scrat is dynamically typed, but not sooo dynamically typed. If everything matches up it creates a new scope("closure"), and inserts key-value pairs for arguments(zip+foreach). And then it evaluates it's body - apply(body)(closure). Mind you, this happens on every execution as createFunFromAst return a function value that, upon execution, does this.<br />Oh yes, there is also a case clause in Evaluator's apply that invokes createFunFromAst, again trivial.<br />Such functions are indistinguishable to native functions from scrat's point of view and are invoked by same syntax and by same code in Evaluator.<br /><h3>A sample</h3></div><div>First thing I tried to implement(literaly) was fibonaci's sequence <br /><pre>func fib(n) { if n==0 then 1 else if n==1 then 1 else fib(n-1) + fib(n-2) }<br />println("20th fibbonacci number is", fib(20))<br /></pre></div><div>Excuse me for the ugly nested if's, but this was neccessary as I have not implemented < yet. But hey, it works.<br /><h4>Sneak peak</h4></div><div>At this point I realised an awesome way to implement objects. With constructors like:<br /><pre>func create(n){this}<br /></pre></div><div><br /><b>next</b> <a href="http://edofic.blogspot.com/2012/09/making-programming-language-part-7.html" target="_blank">objects and costructors</a></div><div></div>